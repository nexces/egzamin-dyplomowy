#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Omówić pojęcie informatyki i jej działy
\end_layout

\begin_layout Standard
Informatyka – dyscyplina nauki zaliczana do nauk ścisłych oraz techniki
 zajmująca się przetwarzaniem informacji, w tym również technologiami przetwarza
nia informacji oraz technologiami wytwarzania systemów przetwarzających
 informację.
 Początkowo stanowiła część matematyki, później rozwinęła się do odrębnej
 dyscypliny – pozostaje jednak nadal w ścisłej relacji z matematyką, która
 dostarcza informatyce podstaw teoretycznych.
 
\end_layout

\begin_layout Standard
Bardziej znane i popularne działy informatyki to przede wszystkim:
\end_layout

\begin_layout Itemize
administracja sieciowa – zarządzanie siecią komputerową;
\end_layout

\begin_layout Itemize
administracja systemem – zarządzanie systemem informatycznym;
\end_layout

\begin_layout Itemize
algorytmika – tworzenie i analizowanie algorytmów.
 Podstawowa, najstarsza dyscyplina informatyki;
\end_layout

\begin_layout Itemize
architektura procesorów – projektowanie procesorów, bez których nie byłoby
 komputerów;
\end_layout

\begin_layout Itemize
bezpieczeństwo komputerowe – dyscyplina łącząca informatykę z telekomunikacją
 w celu zapewnienia poufności i bezpieczeństwa danych;
\end_layout

\begin_layout Itemize
grafika komputerowa – wykorzystuje technikę komputerową w celu wizualizacji
 rzeczywistości;
\end_layout

\begin_layout Itemize
inżynieria oprogramowania – produkcja oprogramowania;
\end_layout

\begin_layout Itemize
języki programowania – tworzenie języków programowania.
 Wyróżniająca się, podstawowa dyscyplina informatyki;
\end_layout

\begin_layout Itemize
programowanie – czyli tworzenie kodu źródłowego programów komputerowych.
 Najpopularniejsza dyscyplina informatyki;
\end_layout

\begin_layout Itemize
sprzęt komputerowy – komputery i ich urządzenia peryferyjne;
\end_layout

\begin_layout Itemize
symulacja komputerowa – komputerowa symulacja z wykorzystaniem modelowania
 matematycznego;
\end_layout

\begin_layout Itemize
systemy informatyczne – tworzenie systemów informatycznych w celach użytkowych;
\end_layout

\begin_layout Itemize
sztuczna inteligencja – komputerowe symulowanie inteligencji;
\end_layout

\begin_layout Itemize
teoria informacji – dyscyplina zajmująca się problematyką informacji, w
 tym teorią przetwarzania i przesyłania informacji;
\end_layout

\begin_layout Itemize
webmastering – projektowanie, programowanie i publikacja serwisów internetowych.
\end_layout

\begin_layout Section
Przedstawić cechy programowania strukturalnego
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Programowanie strukturalne"
target "http://pl.wikipedia.org/wiki/Programowanie_strukturalne"

\end_inset


\end_layout

\begin_layout Itemize
hierarchiczne dzielenie kodu
\end_layout

\begin_layout Itemize
jeden punkt wejścia
\end_layout

\begin_layout Itemize
jeden lub wiele punktów wyjścia
\end_layout

\begin_layout Itemize
nieużywanie lub ograniczenie instrukcji skoku 
\begin_inset Quotes eld
\end_inset

goto
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Dobre struktury:
\end_layout

\begin_layout Itemize
instrukcje warunkowe (if, if...else)
\end_layout

\begin_layout Itemize
pętle (while, repeat)
\end_layout

\begin_layout Itemize
instrukcje wyboru (case, ale nie switch z C i potomnych)
\end_layout

\begin_layout Standard
Strukturalność zakłócają:
\end_layout

\begin_layout Itemize
break
\end_layout

\begin_layout Itemize
switch
\end_layout

\begin_layout Itemize
continue
\end_layout

\begin_layout Section
Scharakteryzować paradygmat programowania obiektowego
\end_layout

\begin_layout Subsection*
Abstrakcja
\end_layout

\begin_layout Standard
Każdy obiekt w systemie służy jako model abstrakcyjnego "wykonawcy", który
 może wykonywać pracę, opisywać i zmieniać swój stan oraz komunikować się
 z innymi obiektami w systemie bez ujawniania, w jaki sposób zaimplementowano
 dane cechy.
 Procesy, funkcje lub metody mogą być również abstrahowane, a kiedy tak
 się dzieje, konieczne są rozmaite techniki rozszerzania abstrakcji.
\end_layout

\begin_layout Subsection*
Hermetyzacja
\end_layout

\begin_layout Standard
Czyli ukrywanie implementacji, enkapsulacja.
 Zapewnia, że obiekt nie może zmieniać stanu wewnętrznego innych obiektów
 w nieoczekiwany sposób.
 Tylko własne metody obiektu są uprawnione do zmiany jego stanu.
 Każdy typ obiektu prezentuje innym obiektom swój interfejs, który określa
 dopuszczalne metody współpracy.
 Pewne języki osłabiają to założenie, dopuszczając pewien poziom bezpośredniego
 (kontrolowanego) dostępu do "wnętrzności" obiektu.
 Ograniczają w ten sposób poziom abstrakcji.
 Przykładowo w niektórych kompilatorach języka C++ istnieje możliwość tymczasowe
go wyłączenia mechanizmu enkapsulacji; otwiera to dostęp do wszystkich pól
 i metod prywatnych, ułatwiając programistom pracę nad pośrednimi etapami
 tworzenia kodu i znajdowaniem błędów.
\end_layout

\begin_layout Subsection*
Polimorfizm
\end_layout

\begin_layout Standard
Referencje i kolekcje obiektów mogą dotyczyć obiektów różnego typu, a wywołanie
 metody dla referencji spowoduje zachowanie odpowiednie dla pełnego typu
 obiektu wywoływanego.
 Jeśli dzieje się to w czasie działania programu, to nazywa się to późnym
 wiązaniem lub wiązaniem dynamicznym.
 Niektóre języki udostępniają bardziej statyczne (w trakcie kompilacji)
 rozwiązania polimorfizmu – na przykład szablony i przeciążanie operatorów
 w C++.
\end_layout

\begin_layout Subsection*
Dziedziczenie
\end_layout

\begin_layout Standard
Porządkuje i wspomaga polimorfizm i enkapsulację dzięki umożliwieniu definiowani
a i tworzenia specjalizowanych obiektów na podstawie bardziej ogólnych.
 Dla obiektów specjalizowanych nie trzeba redefiniować całej funkcjonalności,
 lecz tylko tę, której nie ma obiekt ogólniejszy.
 W typowym przypadku powstają grupy obiektów zwane klasami, oraz grupy klas
 zwane drzewami.
 Odzwierciedlają one wspólne cechy obiektów.
\end_layout

\begin_layout Section
Omówić elementy klasy w programie
\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Klasa (programowanie obiektowe)"
target "http://pl.wikipedia.org/wiki/Klasa_(programowanie_obiektowe)"

\end_inset


\end_layout

\begin_layout Description
Metody określają możliwe zachowania, jake na obiekcie można wykonać, a ich
 definicje znajdują się w klasie danego obiektu.
 Metoda jest rodzajem podprogramu języka programowania z dodatkową właściwością,
 th.
 dostępem do atrybutów obiektu, na którym została wywołana.
 Zbiór metod nazywany jest interfejsem.
\end_layout

\begin_layout Description
Atrubuty, zwane także polami lub właściwościami, są to elementy składające
 się na strukturę danych przechowywanych w obiektach.
 Zbiór wartości wszystkich atrybutów tworzy stan obiektu, który przechowywany
 jest w pamięciu lub innym nośniku danych pod określonym adresem, dzięki
 czemu możliwy jest dostęp do niego za pośrednictwem referencji.
\end_layout

\begin_layout Description
Niezmienniki to elementy stałe zachowywane przez wszystkie metody klasy.
 Niezmiennik jest pewnym wyrażeniem odnoszącym się do atrybutu, które musi
 być zawsze spełnione aby stan obiektu był prawidłowy, niezależnie od tego,
 jakie operacje na nim wykonamy.
 Niezmienniki mogą być implementowane poprzez zabronienie bezpośredniego
 dostępu do atrybutów obiektu i utworzenie dodatkowych metod dostepowych,
 które oprócz ich stawiania, sprawdzają także niezmienniki.
 W niektórych językach niezmienniki można definiować bezpośrednio jako część
 specyfikacji klasy.
\end_layout

\begin_layout Description
Elementy
\begin_inset space ~
\end_inset

statyczne nie są związane z żadnym konkretnym obiektem klasy, lecz tworzą
 globalny stan oraz globalnie dostepne operacje, które można wywoływać nawet
 wtedy, gdy nie posiadamy żadnej instancji klasy.
\end_layout

\begin_layout Section
Scharakteryzować cechy algorytmów, w tym złożoność obliczeniową
\end_layout

\begin_layout Standard
Algorytm – w matematyce oraz informatyce to skończony, uporządkowany ciąg
 jasno zdefiniowanych czynności, koniecznych do wykonania pewnego zadania.
 
\end_layout

\begin_layout Subsection*
Cechy algorytmów
\end_layout

\begin_layout Itemize
poprawność --- algorytm daje dobre wyniki,
\end_layout

\begin_layout Itemize
jednoznaczność --- daje takie same wyniki przy takich samych danych,
\end_layout

\begin_layout Itemize
skończoność --- wykonuje się w skończonej ilości kroków,
\end_layout

\begin_layout Itemize
sprawność --- czasowa; szybkość działania i pamięciowa; "zasobożerność"
\end_layout

\begin_layout Subsection*
Złożoność obliczeniowa
\end_layout

\begin_layout Standard
Ilość zasobów niezbędnych do wykonania algorytmu można rozumieć jako jego
 złożoność.
 W zależności od rozważanego zasobu mówimy o złożoności czasowej czy też
 pamięciowej.
 
\end_layout

\begin_layout Standard
Oczywiście w większości wypadków ilość potrzebnych zasobów będzie się różnić
 w zależności od danych wejściowych z zakresu danego zagadnienia.
 Złożoność algorytmu jest funkcją rozmiaru danych wejściowych.
 
\end_layout

\begin_layout Standard
Kolejnym problemem jest fakt, iż złożoność zwykle nie zależy wyłącznie od
 rozmiaru danych, ale może się znacznie różnić dla danych wejściowych o
 identycznym rozmiarze.
 Dwoma często stosowanymi sposobami podejścia są: rozpatrywanie przypadków
 najgorszych (złożoność pesymistyczna) oraz zastosowanie określonego sposobu
 uśrednienia wszystkich możliwych przypadków (złożoność oczekiwana).
\end_layout

\begin_layout Subsection*
Klasa złożoności
\end_layout

\begin_layout Standard
W teorii obliczeń klasa złożoności to zbiór problemów obliczeniowych o podobnej
 złożoności obliczeniowej.
\end_layout

\begin_layout Standard
Na przykład klasa P to zbiór problemów decyzyjnych, które można rozwiązać
 na maszynie Turinga w czasie wielomianowym, natomiast klasa NP to zbiór
 problemów decyzyjnych, które można rozwiązać na niedeterministycznej maszynie
 Turinga w czasie wielomianowym.
 
\end_layout

\begin_layout Section
Wyjaśnić pojęcie algorytmu i dokonać klasyfikacji algorytmów wg wybranych
 kryteriów
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Algorytm"
target "http://pl.wikipedia.org/wiki/Algorytm"

\end_inset

 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia (ENG) :: Algorytm"
target "http://en.wikipedia.org/wiki/Algorithm"

\end_inset


\end_layout

\begin_layout Description
Algorytm skończony ciąg jasno zdefiniowanych czynności, koniecznych do wykonania
 pewnego rodzaju zadań.
 Algorytm ma przeprowadzić system z pewnego stanu początkowego do pożądanego
 stanu końcowego.
\end_layout

\begin_layout Description
Algorytm to jednoznaczny przepis obliczenia w skończonym czasie pewnych
 danych wejściowych do pewnych danych wynikowych.
\end_layout

\begin_layout Standard
Klasyfikacja, ze względu na:
\end_layout

\begin_layout Itemize
implementację
\end_layout

\begin_deeper
\begin_layout Description
rekursywne,
\begin_inset space ~
\end_inset

iteracyjne algorytm rekursywny wywołuje sam siebie dopóki nie zostaną spełnione
 pewne warunki; algorytm iteracyjny wykorzystuje pętle i czasem dodatkowe
 struktury danych aby rozwiązać dany problem
\end_layout

\begin_layout Description
logiczne
\end_layout

\begin_layout Description
szeregowe,
\begin_inset space ~
\end_inset

równoległe,
\begin_inset space ~
\end_inset

rozproszone
\end_layout

\begin_layout Description
deterministyczne,
\begin_inset space ~
\end_inset

niestederministyczne
\end_layout

\begin_layout Description
dokładne,
\begin_inset space ~
\end_inset

przybliżeniowe
\end_layout

\begin_layout Description
kwantowe?
\end_layout

\end_deeper
\begin_layout Itemize
metodę działania
\end_layout

\begin_layout Itemize
obszar problemu
\end_layout

\begin_layout Itemize
złożoność
\end_layout

\begin_layout Section
Scharakteryzować język programowania i podać wybrane klasyfikacje języków
\end_layout

\begin_layout Subsection*
Język programowania
\end_layout

\begin_layout Standard
Podobnie jak języki naturalne, język programowania składa się ze zbiorów
 reguł syntaktycznych oraz semantyki, które opisują, jak należy budować
 poprawne wyrażenia oraz jak komputer ma je rozumieć.
 Język programowania pozwala na precyzyjny zapis algorytmów oraz innych
 zadań, jakie komputer ma wykonać.
\end_layout

\begin_layout Subsection*
Klasyfikacja pod względem wykorzystanych paradygmatów
\end_layout

\begin_layout Itemize
Programowanie proceduralne --- zaleca dzielenie kodu na procedury, czyli
 fragmenty wykonujące ściśle określone operacje,
\end_layout

\begin_layout Itemize
Programowanie strukturalne --- zaleca hierarchiczne dzielenie kodu na bloki,
 z jednym punktem wejścia i jednym lub wieloma punktami wyjścia.
 Chodzi przede wszystkim o nieużywanie (lub ograniczenie) instrukcji skoku
 (goto),
\end_layout

\begin_layout Itemize
Programowanie funkcyjne --- funkcje należą do wartości podstawowych, a nacisk
 kładzie się na wartościowanie (często rekurencyjnych) funkcji, a nie na
 wykonywanie poleceń,
\end_layout

\begin_layout Itemize
Programowanie imperatywne --- opisuje proces wykonywania jako sekwencję
 instrukcji zmieniających stan programu; programy imperatywne składają się
 z ciągu komend do wykonania przez komputer,
\end_layout

\begin_layout Itemize
Programowanie obiektowe --- programy definiuje się za pomocą obiektów ---
 elementów łączących stan (czyli dane, nazywane najczęściej polami) i zachowanie
 (czyli procedury, tu: metody); obiektowy program komputerowy wyrażony jest
 jako zbiór takich obiektów, komunikujących się pomiędzy sobą w celu wykonywania
 zadań,
\end_layout

\begin_layout Itemize
Programowanie uogólnione (generyczne np.
 C++, Scala) --- pozwala na pisanie kodu programu bez wcześniejszej znajomości
 typów danych, na których kod ten będzie pracował,
\end_layout

\begin_layout Itemize
Programowanie zdarzeniowe --- program jest cały czas bombardowany zdarzeniami
 (events), na które musi odpowiedzieć; przepływ sterowania w programie jest
 całkowicie niemożliwy do przewidzenia z góry
\end_layout

\begin_layout Itemize
Programowanie logiczne (np.
 Prolog) --- odmiana programowania deklaratywnego, w której program podawany
 jest jako pewien zestaw zależności, a obliczenia są dowodem pewnego twierdzenia
 w oparciu o te zależności,
\end_layout

\begin_layout Itemize
Programowanie aspektowe (np.
 AspectJ) --- wspomaga separację zagadnień i rozdzielenie programu na części
 w jak największym stopniu niezwiązane funkcjonalnie; oddziela fizycznie
 kod każdego zagadnienia poprzez umieszczenie ich w oddzielnych aspektach
 i logiczne zdefiniowanie punktów interakcji pomiędzy nimi,
\end_layout

\begin_layout Itemize
Programowanie deklaratywne --- w przeciwieństwie do programów napisanych
 imperatywnie, programista opisuje warunki, jakie musi spełniać końcowe
 rozwiązanie (co chcemy osiągnąć), a nie szczegółową sekwencję kroków, które
 do niego prowadzą (jak to zrobić),
\end_layout

\begin_layout Itemize
Programowanie agentowe --- wyższy od abstrakcji programowania obiektowego;
 polega on na tworzeniu agentów, które muszą być przygotowane na otrzymanie
 błędnych danych od innego agenta, lub nieotrzymanie ich w ogóle, 
\end_layout

\begin_layout Itemize
Programowanie modularne --- zaleca stosowanie nadrzędności modułów w stosunku
 do procedur i bloków tworzących program; moduł grupuje funkcjonalnie związane
 ze sobą dane oraz procedury i jest reprezentacją obiektu jednokrotnie występują
cego w programie
\end_layout

\begin_layout Section
Porównać język Java oraz C++
\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia (ENG) :: Comparison of Java and C++"
target "http://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B"

\end_inset


\end_layout

\begin_layout Itemize
Brak refleksji w C++
\end_layout

\begin_layout Itemize
Kompilacja do natywnego kodu a maszyna wirtualna i bajtkod
\end_layout

\begin_layout Itemize
C++ wymaga ręcznego zarządzania pamięcią a w Javie jest GC
\end_layout

\begin_layout Itemize
Java wymaga stosowania JNI do dostępu do natywnych bibliotek
\end_layout

\begin_layout Itemize
...
\end_layout

\begin_layout Section
Scharakteryzować wybrane środowisko programistyczne języka C++
\end_layout

\begin_layout Subsection*
Borland
\end_layout

\begin_layout Subsection*
Eclipse
\end_layout

\begin_layout Subsection*
Visual Studio
\end_layout

\begin_layout Subsection*
DEV C++
\end_layout

\begin_layout Itemize
wbudowany kompilator
\end_layout

\begin_layout Itemize
wbudowany debuger
\end_layout

\begin_layout Itemize
kontrola wersji
\end_layout

\begin_layout Itemize
edytor kodu
\end_layout

\begin_deeper
\begin_layout Itemize
podświetlenie składni
\end_layout

\begin_layout Itemize
podpowiedzi
\end_layout

\end_deeper
\begin_layout Itemize
tworzenie zasobów programu
\end_layout

\begin_layout Itemize
tworzenie baz danych
\end_layout

\begin_layout Itemize
tworzenie komponentów
\end_layout

\begin_layout Section
Scharakteryzować wybrane środowisko programistyczne języka Java
\end_layout

\begin_layout Standard
Eclipse bądź Netbeans.
 Tak samo jak w 9.
\end_layout

\begin_layout Standard
Tylko nie wiem co tu opowiadać :/
\end_layout

\begin_layout Section
Omówić dwa wybrane algorytmy sortowania
\end_layout

\begin_layout Subsection*
Sortowanie przez scalanie
\end_layout

\begin_layout Standard
Wyróżnić można trzy podstawowe kroki:
\end_layout

\begin_layout Enumerate
Podziel zestaw danych na dwie równe części
\end_layout

\begin_layout Enumerate
Zastosuj sortowanie przez scalanie dla każdej z nich oddzielnie, chyba że
 pozostał już tylko jeden element;
\end_layout

\begin_layout Enumerate
Połącz posortowane podciągi w jeden.
\end_layout

\begin_layout Standard
Dobra implementacja w C jest tylko 20% wolniejsza od quicksort.
\end_layout

\begin_layout Subsection*
Sortowanie bąbelkowe
\end_layout

\begin_layout Standard
Polega na porównywaniu dwóch kolejnych elementów i zamianie ich kolejności,
 jeżeli zaburza ona porządek, w jakim się sortuje tablicę.
 Sortowanie kończy się, gdy podczas kolejnego przejścia nie dokonano żadnej
 zmiany.
 
\end_layout

\begin_layout Section
Wyjaśnić zasady działania instrukcji warunkowej i instrukcji pętli w wybranym
 języku programowania
\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Instrukcja warunkowa"
target "http://pl.wikipedia.org/wiki/Instrukcja_warunkowa#If-Then"

\end_inset

 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Pętla"
target "http://pl.wikipedia.org/wiki/P%C4%99tla_(informatyka)"

\end_inset


\end_layout

\begin_layout Standard
Podstawowym rodzajem instrukcji warunkowej jest If-Then.
 Jest spotykany w większości języków programowania i umożliwia warunkowe
 wykonanie określonego bloku kodu, a jeśli warunek nie jest spełniony –
 alternatywnego bloku.
 Pomiędzy językami występują nieznaczne różnice składniowe, ale ogólny schemat
 w pseudokodzie zawsze wygląda następująco:
\end_layout

\begin_layout Quotation
if warunek then
\end_layout

\begin_layout Quotation
właściwy blok kodu
\end_layout

\begin_layout Quotation
else
\end_layout

\begin_layout Quotation
alternatywny blok kodu
\end_layout

\begin_layout Quotation
end if
\end_layout

\begin_layout Standard
Na początku wykonywana jest ewaluacja warunku podanego w postaci wyrażenia
 logicznego.
 Jeśli wynikiem jest true, wykonywany jest właściwy blok kodu, a jeśli false
 – alternatywny.
 Następnie program kontynuuje od pierwszej komendy po end if.
\end_layout

\begin_layout Standard
Wiele języków programowania umożliwia zdefiniowanie więcej niż jednego warunku
 do sprawdzenia przy pomocy opcjonalnego bloku else-if:
\end_layout

\begin_layout Quotation
if warunek 1 then
\end_layout

\begin_layout Quotation
pierwszy blok kodu
\end_layout

\begin_layout Quotation
else-if warunek 2 then
\end_layout

\begin_layout Quotation
drugi blok kodu
\end_layout

\begin_layout Quotation
else-if warunek 3 then
\end_layout

\begin_layout Quotation
trzeci blok kodu
\end_layout

\begin_layout Quotation
else
\end_layout

\begin_layout Quotation
alternatywny blok kodu
\end_layout

\begin_layout Quotation
end if
\end_layout

\begin_layout Standard
W tym wypadku warunki ewaluowane są po kolei do momentu, gdy któryś z nich
 nie da wartości true – wykonywany jest wtedy przypisany mu blok kodu.
 Jeśli żaden z warunków nie będzie prawdziwy, wykonywany jest blok alternatywny.
 Bez względu na ilość prawdziwych warunków, zawsze wykona się tylko pierwszy
 z nich, a pozostałe zostaną pominięte.
\end_layout

\begin_layout Section
Scharakteryzować wybrany język skryptowy
\end_layout

\begin_layout Subsection*
Ruby
\end_layout

\begin_layout Standard
Ruby to nowoczesny i dojrzały język programowania.
 Zapożycza wiele elementów z języków programowania takich jak Perl, Smalltalk,
 Eiffel, Ada czy Lisp.
 Łączy w sobie programowanie obiektowe, funkcjonalne oraz imperatywne.
\end_layout

\begin_layout Standard
Został opracowany przez Yukihiro “matz” Matsumoto jako narzędzie dla administrat
orów systemów uniksowych, które miało zastąpić język Perl.
 Jednak dzięki powstaniu frameworku do tworzenia aplikacji internetowych
 Ruby on Rails (RoR) Ruby ogromnie zyskał na popularności.
\end_layout

\begin_layout Subsection*
Cechy szczególne języka Ruby
\end_layout

\begin_layout Standard
Oto kilka charakterystycznych cech języka Ruby, dzięki którym jest on wygodnym
 i potężnym narzędziem:
\end_layout

\begin_layout Subsubsection*
Bloki i lambdy
\end_layout

\begin_layout Standard
Bloki i lambdy umożliwiające tak zwane domknięcia pozwalają na zamykanie
 bloku kodu oraz zmiennych z otaczającego kontekstu i przekazywanie ich
 innym obiektom.
 Są to bardzo wygodne i łatwe w użyciu narzędzia do tworzenia wywołań zwrotnych,
 filtrów, bloków iteracji a nawet elementów własnego języka domenowego 
\lang american
(Domain-specific Language
\lang polish

\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Domain-specific_language
\end_layout

\end_inset

 --- DSL).
 W odróżnieniu od anonimowych funkcji czy klas znanych z innych języków,
 dedykowana składnia i możliwość odwoływania się do zmiennych z otaczającego
 kontekstu umożliwia pisanie w sposób funkcjonalny, niemal w tak elastyczny
 sposób jak w języku Lisp.
 
\end_layout

\begin_layout Subsubsection*
"Duck typing"
\end_layout

\begin_layout Standard
Ruby nie wymaga od programisty deklarowania typów zmiennych.
 Dzięki temu programista może skupić się na logice programu nie martwiąc
 się o interfejsy, typy, deklaracje i inne elementy kodu potrzebne w statycznie
 typowanych językach programowania.
 W Ruby 
\begin_inset Quotes eld
\end_inset

jak coś kwacze jak kaczka to jest kaczką
\begin_inset Quotes erd
\end_inset

 co oznacza, że wystarczy żeby przekazany obiekt miał potrzebne metody aby
 mógł być wykorzystany w danej roli.
\end_layout

\begin_layout Standard
Wadą takiego rozwiązania jest to, że kompilator nie prowadzi programisty
 za rękę.
 Powoduje to, że programy Ruby wymagają intensywnego automatycznego testowania,
 a zespoły pracujące przy pojedynczym module lub programie nie mogą być
 zbyt duże.
 Osobiście uważam, że w rezultacie uzyskujemy dobrze przetestowany i modułowy
 kod.
\end_layout

\begin_layout Subsubsection*
Automatyczne odśmiecanie pamięci
\end_layout

\begin_layout Standard
W Ruby programista nie musi się martwić alokacją i zwalnianiem pamięci.
 Implementacje Ruby wykorzystują nowoczesne implementacje 
\lang american
Garbage Collector
\lang polish
 (GC)
\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
\end_layout

\end_inset

 takie jak Mark-and-Seweep.
\end_layout

\begin_layout Subsubsection*
Wszystko jest obiektem
\end_layout

\begin_layout Standard
Ruby jest językiem w pełni obiektowym.
 Każdy element tego języka reprezentowany jest przez obiekt.
 W wielu językach, liczby i inne typy podstawowe nie są obiektami.
 Ruby podąża za Smalltalkiem udostępniając metody i zmienne instancji wszystkim
 swoim typom.
 To ułatwia korzystanie z języka, ponieważ reguły mające zastosowanie do
 obiektów odnoszą się również do całego języka.
\end_layout

\begin_layout Subsubsection*
Wszystkie wyrażenia zwracają wartość
\end_layout

\begin_layout Standard
W Ruby każde wyrażenie --- nawet takie jak wyrażenia warunkowe --- zwraca
 wartość.
 W wyniku czego programy napisane w Ruby są bardziej ekspresyjne i treściwe.
\end_layout

\begin_layout Subsubsection*
Prawda w Ruby
\end_layout

\begin_layout Standard
Wszystko co nie jest wartością 
\emph on
\lang american
nil
\emph default
\lang polish
 lub 
\emph on
\lang american
false
\emph default
\lang polish
 jest prawdą.
 Ta prosta zasada powoduje że pisanie wyrażeń warunkowych staje się proste
 i bardzo intuicyjne.
\end_layout

\begin_layout Subsubsection*
Wyrażenia logiczne zapożyczone z języka Lisp
\end_layout

\begin_layout Standard
Tak jak w języku Lisp argumenty wyrażeń 
\emph on
or
\emph default
 czy 
\emph on
and
\emph default
 są ewaluowane tylko gdy jest to konieczne do ustalenia wartości logicznej
 danego wyrażenia.
 W następstwie tego za pomocą operatorów logicznych można pisać proste wyrażenia
 warunkowe.
\end_layout

\begin_layout Subsubsection*
Mixin-y
\end_layout

\begin_layout Standard
W Ruby niemożliwe jest wielokrotne dziedziczenie.
 Jest tak ze względu na to, że wielokrotne dziedziczenie bardzo komplikuje
 język programowania (dobrym przykładem jest język C++).
 W zamian Ruby oferuje dużo prostszy i wygodniejszy mechanizm zwany 
\emph on
mixin
\emph default
.
 Polega to na tym, że do klas bądź pojedynczych obiektów można dołączyć
 wcześniej zdefiniowany zestaw metod.
 Umożliwia to rozszerzanie dowolnych klas i obiektów o zestaw nowych zachowań.
\end_layout

\begin_layout Subsubsection*

\lang american
Meta programing
\end_layout

\begin_layout Standard
Ruby umożliwia definiowanie klas, obiektów i metod z poziomu samego języka.
 Daje to możliwość programowi na dostosowanie interfejsu klasy na przykład
 do zestawu kolumn obecnych w tabeli bazy danych z którą się komunikuje.
 Ta możliwość jest kluczem do sukcesu 
\lang american
Ruby on Rails
\lang polish
.
 Umożliwia wyeliminowanie potrzeby konfiguracji różnych aspektów programów
 wdrażając mantrę 
\begin_inset Quotes eld
\end_inset

konwencja ponad konfiguracją
\begin_inset Quotes erd
\end_inset

 (ang.
 
\lang american
convention over configuration
\lang polish
).
\end_layout

\begin_layout Section
[TODO] Omówić system stron WWW
\end_layout

\begin_layout Section
Scharakteryzować zasady instalacji i administrowania serwerami internetowymi.
 
\end_layout

\begin_layout Itemize
bezpieczeństwo fizyczne komputera
\end_layout

\begin_deeper
\begin_layout Itemize
zasilanie
\end_layout

\begin_layout Itemize
chłodzenie
\end_layout

\begin_layout Itemize
RAID
\end_layout

\begin_layout Itemize
kontrola fizycznego dostępu
\end_layout

\end_deeper
\begin_layout Itemize
izolacja procesów - user, chroot...
\end_layout

\begin_layout Itemize
minimalna ilość usług
\end_layout

\begin_layout Itemize
firewall
\end_layout

\begin_layout Itemize
monitoring
\end_layout

\begin_layout Itemize
logowanie
\end_layout

\begin_layout Section
Porównać systemy operacyjne klasy Windows i Unix 
\end_layout

\begin_layout Standard
Wywodzą się z innych środowisk i zastosowań.
\end_layout

\begin_layout Standard
- desktop PC
\end_layout

\begin_layout Standard
- serwery obsługujące wielu użytkowników na raz na sprzęcie 
\begin_inset Quotes eld
\end_inset

mainframe
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Section
Scharakteryzować modele cyklu „życia” systemu informatycznego 
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs8.chomikuj.pl/196923976,PL,0,0,Cykl-zycia-systemu-informatycznego.doc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Życie systemu – uporządkowany szereg prac (wzajemnie spójnych etapów) wykonanych
 przy tworzeniu systemu informatycznego.
 Poprzez analogię do życia ludzkiego wyróżnić możemy trzy podstawowe fazy:
\end_layout

\begin_layout Enumerate
Faza narodzin – moment uświadamiania sobie (zgłoszenia) potrzeby istnienia
 systemu; początek fazy wzrostu
\end_layout

\begin_layout Enumerate
Faza wzrostu (eksploatacji) – kolejne działania pozwalające na pełne i skuteczne
 stworzenie, a następnie użytkowanie systemu
\end_layout

\begin_layout Enumerate
Faza śmierci – moment zaprzestania eksploatacji systemu.
\end_layout

\begin_layout Standard
W cyklu życia systemu informatycznego najczęściej jednak wyodrębnia się
 następujące fazy:
\end_layout

\begin_layout Enumerate
Analiza wymagań
\end_layout

\begin_layout Enumerate
Projekt
\end_layout

\begin_layout Enumerate
Implementacja (kodowanie)
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Instalacja
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Wycofanie
\end_layout

\begin_layout Subsection*
Model kaskadowy
\end_layout

\begin_layout Enumerate
Analiza potrzeb
\end_layout

\begin_layout Enumerate
Specyfikacja systemu
\end_layout

\begin_layout Enumerate
Projektowanie
\end_layout

\begin_layout Enumerate
Programowanie
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Integracja
\end_layout

\begin_layout Enumerate
Adaptacja i modyfikacja
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Dezaktualizacja
\end_layout

\begin_layout Subsection*
Model Fry’ego
\end_layout

\begin_layout Enumerate
Projektowania – realizowane są
\end_layout

\begin_deeper
\begin_layout Enumerate
Formułowanie i analiza potrzeb
\end_layout

\begin_layout Enumerate
Modelowanie konceptualny (opis modelu danych, modelu procesu danych w systemie)
\end_layout

\begin_layout Enumerate
Projektowanie fizyczne
\end_layout

\end_deeper
\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_deeper
\begin_layout Enumerate
Wdrożenie
\end_layout

\begin_layout Enumerate
Eksploatacja
\end_layout

\begin_layout Enumerate
Kontrola
\end_layout

\begin_layout Enumerate
Modyfikacja i adaptacja.
\end_layout

\end_deeper
\begin_layout Subsection*
Model z prototypem
\end_layout

\begin_layout Standard
Polega na budowaniu prototypu, który prezentowany jest użytkownikowi celem
 weryfikacji i na tej podstawie modyfikowany.
 Takie podejście ma na celu zredukowanie czasu oczekiwania na konkretne
 rezultaty, zapewnienie szybkiego sprzężenia zwrotnego pomiędzy użytkownikiem
 a projektantem, a także zaangażowanie użytkownika w projektowanie i analizę
 potrzeb.
 
\end_layout

\begin_layout Enumerate
Ogólne określenie potrzeb użytkownika
\end_layout

\begin_layout Enumerate
Konstruowanie prototypu
\end_layout

\begin_layout Enumerate
Użycie i weryfikacja prototypu
\end_layout

\begin_layout Enumerate
Modyfikacja prototypu (w zależności od wcześniejszej oceny klienta po wprowadzen
iu zmian następuje powrót do punktu poprzedniego lub następnego)
\end_layout

\begin_layout Enumerate
Przekształcenie w ostatecznie funkcjonujący system
\end_layout

\begin_layout Enumerate
Eksploatacja i modyfikacja systemu
\end_layout

\begin_layout Standard
W zależności od wyników prezentacji możemy mieć do czynienia z jednym z
 dwóch modeli prototypów: 
\end_layout

\begin_layout Enumerate
Tymczasowy --- prototyp odrzucony; stworzony na potrzeby zrozumienie potrzeb
 klienta; może nigdy nie być przekształcony w ostatecznie funkcjonujący
 system,
\end_layout

\begin_layout Enumerate
Rozwojowy --- prototyp przekształcany w ostatecznie funkcjonujący system.
\end_layout

\begin_layout Subsection*
Model spiralny
\end_layout

\begin_layout Enumerate
planowania
\end_layout

\begin_layout Enumerate
analizy ryzyka
\end_layout

\begin_layout Enumerate
konstruowania
\end_layout

\begin_layout Enumerate
weryfikacji.
\end_layout

\begin_layout Standard
Pracę rozpoczynamy od wstępnych wymagań i planowania projektu, następnie
 na ich podstawie analizujemy ryzyko i konstruujemy wstępny prototyp, który
 zostaje poddany weryfikacji przez użytkownika.
 W kolejnym cyklu planujemy zmiany i analizujemy ryzyko oparte na reakcji
 użytkownika, po czym tworzymy kolejny prototyp do weryfikacji.
 Po kolejnych kilku przebiegach należy spodziewać się, że system przyjmie
 oczekiwaną postać i zakończymy pracę konstrukcją systemu.
 
\end_layout

\begin_layout Section
Omówić etapy tworzenia systemu informatycznego
\end_layout

\begin_layout Enumerate
Specyfikacja wymagań
\end_layout

\begin_layout Enumerate
Projektowanie
\end_layout

\begin_layout Enumerate
Implementacja
\end_layout

\begin_layout Enumerate
Testowanie
\end_layout

\begin_layout Enumerate
Wdrożenie i pielęgnacja
\end_layout

\begin_layout Section
Wyjaśnij pojęcia: baza danych, system zarządzania bazami danych oraz integralnoś
ć danych.
\end_layout

\begin_layout Subsection*
Baza danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Baza_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zbiór danych zapisanych zgodnie z określonymi regułami.
 W węższym znaczeniu obejmuje dane cyfrowe gromadzone zgodnie z zasadami
 przyjętymi dla danego programu komputerowego specjalizowanego do gromadzenia
 i przetwarzania tych danych.
\end_layout

\begin_layout Subsection*
System zarządzania bazą danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/System_zarządzania_bazą_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
System zarządzania bazą danych, SZBD (ang.
 Database Management System, DBMS) – oprogramowanie bądź system informatyczny
 służący do zarządzania bazą danych.
 System zarządzania bazą danych może być również serwerem bazy danych (SBD)
 lub też może udostępniać bazę danych lokalnie – na określonym komputerze.
 
\end_layout

\begin_layout Subsection*
Integralność danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Integralność_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funkcja bezpieczeństwa polegająca na tym, że dane nie zostały zmienione,
 dodane lub usunięte w nieautoryzowany sposób.
\end_layout

\begin_layout Standard
W odniesieniu do relacyjnych baz danych integralność definiowana jest jako
 połączenie trzech koncepcji: 
\end_layout

\begin_layout Itemize
dokładność (ang.
 accuracy), 
\end_layout

\begin_layout Itemize
prawdziwość (ang.
 correctness), 
\end_layout

\begin_layout Itemize
oraz aktualność (ang.
 validity).
 
\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Model_relacyjny#Integralno.C5.9B.C4.87
\end_layout

\end_inset

Integralność to ograniczenie nakładane na bazę danych przez model relacyjny.
 Dwie podstawowe reguły integralności to integralność encji (wartość klucza
 głównego nie może być wartością NULL) oraz integralność odwołań (nie mogą
 istnieć niedopasowane wartości klucza obcego).
 
\end_layout

\begin_layout Section
Język baz danych SQL
\end_layout

\begin_layout Standard
Użycie SQL, zgodnie z jego nazwą, polega na zadawaniu zapytań do bazy danych.
 Zapytania można zaliczyć do jednego z czterech głównych podzbiorów:
\end_layout

\begin_layout Standard
SQL DML (ang.
 Data Manipulation Language – „język manipulacji danymi”),
\end_layout

\begin_layout Standard
SQL DDL (ang.
 Data Definition Language – „język definicji danych”),
\end_layout

\begin_layout Standard
SQL DCL (ang.
 Data Control Language – „język kontroli nad danymi”).
\end_layout

\begin_layout Standard
SQL DQL (ang.
 Data Query Language – „język definiowania zapytań”).
\end_layout

\begin_layout Standard
Instrukcje SQL w obrębie zapytań tradycyjnie zapisywane są wielkimi literami,
 jednak nie jest to wymóg.
 Każde zapytanie w SQL-u musi kończyć się znakiem średnika (;).
\end_layout

\begin_layout Standard
Dodatkowo, niektóre programy do łączenia się z silnikiem bazy danych (np.
 psql w przypadku PostgreSQL), używają swoich własnych instrukcji, spoza
 standardu SQL, które służą np.
 do połączenia się z bazą, wyświetlenia dokumentacji itp.
\end_layout

\begin_layout Subsection
DML
\end_layout

\begin_layout Standard
DML (Data Manipulation Language) służy do wykonywania operacji na danych
 – do ich umieszczania w bazie, kasowania, przeglądania oraz dokonywania
 zmian.
 Najważniejsze polecenia z tego zbioru to:
\end_layout

\begin_layout Standard
INSERT – umieszczenie danych w bazie,
\end_layout

\begin_layout Standard
UPDATE – zmiana danych,
\end_layout

\begin_layout Standard
DELETE – usunięcie danych z bazy.
\end_layout

\begin_layout Standard
Dane tekstowe muszą być zawsze ujęte w znaki pojedynczego cudzysłowu (').
\end_layout

\begin_layout Subsection
DDL
\end_layout

\begin_layout Standard
Dzięki DDL (Data Definition Language) można operować na strukturach, w których
 dane są przechowywane – czyli np.
 dodawać, zmieniać i kasować tabele lub bazy.
 Najważniejsze polecenia tej grupy to:
\end_layout

\begin_layout Standard
CREATE (np.
 CREATE TABLE, CREATE DATABASE, ...) – utworzenie struktury (bazy, tabeli,
 indeksu itp.),
\end_layout

\begin_layout Standard
DROP (np.
 DROP TABLE, DROP DATABASE, ...) – usunięcie struktury,
\end_layout

\begin_layout Standard
ALTER (np.
 ALTER TABLE ADD COLUMN ...) – zmiana struktury (dodanie kolumny do tabeli,
 zmiana typu danych w kolumnie tabeli).
\end_layout

\begin_layout Subsection
DCL
\end_layout

\begin_layout Standard
DCL (Data Control Language) ma zastosowanie do nadawania uprawnień do obiektów
 bazodanowych.
 Najważniejsze polecenia w tej grupie to:
\end_layout

\begin_layout Standard
GRANT - służące do nadawania uprawnień do pojedynczych obiektów lub globalnie
 konkretnemu użytkownikowi (np.
 GRANT ALL PRIVILEGES ON EMPLOYEE TO PIOTR WITH GRANT OPTION – przyznanie
 wszystkich praw do tabeli EMPLOYEE użytkownikowi PIOTR z opcją pozwalającą
 mu nadawać prawa do tej tabeli).
\end_layout

\begin_layout Standard
REVOKE – służące do odbierania wskazanych uprawnień konkretnemu użytkownikowi
 (np.
 REVOKE ALL PRIVILEGES ON EMPLOYEE FROM PIOTR - odebranie użytkownikowi
 wszystkich praw do tabeli EMPLOYEE).
\end_layout

\begin_layout Standard
DENY.
\end_layout

\begin_layout Subsection
DQL
\end_layout

\begin_layout Standard
DQL (Data Query Language) to język formułowania zapytań do bazy danych.
 W zakres tego języka wchodzi jedno polecenie - SELECT.
 Często SELECT traktuje się jako część języka DML, ale to podejście nie
 wydaje się właściwe, ponieważ DML z definicji służy do manipulowania danymi
 - ich tworzenia, usuwania i uaktualniania.
\end_layout

\begin_layout Standard
Na pograniczu obu języków znajduje się polecenie SELECT INTO, które dodatkowo
 modyfikuje (przepisuje, tworzy) dane.
\end_layout

\begin_layout Subsection
Przykładowe zapytania
\end_layout

\begin_layout Standard
Przykłady użycia wyżej wymienionych rodzajów zapytań:
\end_layout

\begin_layout Standard
SELECT *
\end_layout

\begin_layout Standard
FROM pracownicy
\end_layout

\begin_layout Standard
WHERE pensja > 2000
\end_layout

\begin_layout Standard
ORDER BY staz DESC;
\end_layout

\begin_layout Standard
Zwraca tabelę (listę) utworzoną ze wszystkich kolumn (*) tabeli „pracownicy”
 (FROM pracownicy) zawierającą pracowników, których pensja jest większa
 niż 2000 (WHERE pensja > 2000) i sortuje wynik malejąco według parametru
 staz (ORDER BY staz DESC).
\end_layout

\begin_layout Standard
INSERT INTO pracownicy
\end_layout

\begin_layout Standard
(imie, nazwisko, pensja, staz)
\end_layout

\begin_layout Standard
VALUES
\end_layout

\begin_layout Standard
('Jan', 'Kowalski', 5500, 1);
\end_layout

\begin_layout Standard
Dodaje do tabeli „pracownicy” (INTO pracownicy) wiersz (rekord) zawierający
 dane pojedynczego pracownika.
\end_layout

\begin_layout Standard
UPDATE pracownicy
\end_layout

\begin_layout Standard
SET pensja = pensja * 1.1
\end_layout

\begin_layout Standard
WHERE staz > 2;
\end_layout

\begin_layout Standard
Podwyższa o 10% pensję (SET pensja = pensja * 1.1) pracownikom, których staż
 jest większy niż 2 (np.
 lata).
\end_layout

\begin_layout Standard
DELETE FROM pracownicy
\end_layout

\begin_layout Standard
WHERE imie = 'Jan' AND nazwisko = 'Kowalski';
\end_layout

\begin_layout Standard
Usuwa z tabeli „pracownicy” wszystkie wiersze (rekordy) dotyczące pracownika
 o imieniu „Jan” i nazwisku „Kowalski” (czyli takie, w których pole "imię"
 ma wartość Jan, a pole "nazwisko" – Kowalski).
\end_layout

\begin_layout Standard
CREATE TABLE pracownicy
\end_layout

\begin_layout Standard
(
\end_layout

\begin_layout Standard
imie VARCHAR(255), 
\end_layout

\begin_layout Standard
nazwisko VARCHAR(255), 
\end_layout

\begin_layout Standard
pensja FLOAT,
\end_layout

\begin_layout Standard
staz INT
\end_layout

\begin_layout Standard
);
\end_layout

\begin_layout Standard
Tworzy tabelę „pracownicy” zawierającą pola tekstowe zmiennej długości (varchar)
 o nazwach „imie” (imię) i „nazwisko”, o maksymalnej długości 255 znaków,
 zapisaną za pomocą liczby rzeczywistej (float od ang.
 floating point) pensję oraz zapisany za pomocą liczby całkowitej (int od
 ang.
 integer) staż.
\end_layout

\begin_layout Standard
DROP TABLE pracownicy;
\end_layout

\begin_layout Standard
Usuwa z bazy tabelę „pracownicy”.
\end_layout

\begin_layout Standard
ALTER TABLE pracownicy
\end_layout

\begin_layout Standard
ADD dzial VARCHAR(255);
\end_layout

\begin_layout Standard
Dodaje do struktury tabeli „pracownicy” kolumnę „dzial” (dział), jako pole
 tekstowe o długości maks.
 255 bajtów.
\end_layout

\begin_layout Section
Instrukcje definiujące dane w SQL
\end_layout

\begin_layout Standard
Dzięki DDL (Data Definition Language) można operować na strukturach, w których
 dane są przechowywane – czyli np.
 dodawać, zmieniać i kasować tabele lub bazy.
 Najważniejsze polecenia tej grupy to:
\end_layout

\begin_layout Itemize
CREATE (np.
 CREATE TABLE, CREATE DATABASE, ...) – utworzenie struktury (bazy, tabeli,
 indeksu itp.),
\end_layout

\begin_layout Itemize
DROP (np.
 DROP TABLE, DROP DATABASE, ...) – usunięcie struktury,
\end_layout

\begin_layout Itemize
ALTER (np.
 ALTER TABLE ADD COLUMN ...) – zmiana struktury (dodanie kolumny do tabeli,
 zmiana typu danych w kolumnie tabeli).
\end_layout

\begin_layout Section
Zapytania wybierające SQL
\end_layout

\begin_layout Standard
Patrz wyżej DQL.
\end_layout

\begin_layout Section
Relacyjne bazy danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Relacyjny_model_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Model relacyjny – model organizacji danych bazujący na matematycznej teorii
 mnogości, w szczególności na pojęciu relacji.
 Na modelu relacyjnym oparta jest relacyjna baza danych (ang.
 Relational Database) – baza danych, w której dane są przedstawione w postaci
 relacyjnej.
 
\end_layout

\begin_layout Standard
W najprostszym ujęciu w modelu relacyjnym dane grupowane są w relacje, które
 reprezentowane są przez tablice.
 Relacje są pewnym zbiorem rekordów o identycznej strukturze wewnętrznie
 powiązanych za pomocą związków zachodzących pomiędzy danymi.
 Relacje zgrupowane są w tzw.
 schematy bazy danych.
 Relacją może być tabela zawierająca dane teleadresowe pracowników, zaś
 schemat może zawierać wszystkie dane dotyczące firmy.
 Takie podejście w porównaniu do innych modeli danych ułatwia wprowadzanie
 zmian, zmniejsza możliwość pomyłek, ale dzieje się to kosztem wydajności.
 
\end_layout

\begin_layout Standard
System zarządzania relacyjną bazą danych (ang.
 Relational Database Management System, RDBMS) – to zestaw programów służących
 do korzystania z bazy danych opartej na modelu relacyjnym.
 Większość wewnętrznych języków RDBMS jest w pewnym stopniu zgodna ze standardem
 języka zapytań SQL.
 Język ten doczekał się już dwóch standardów – SQL92 i SQL99, jednak różnice
 pomiędzy teoretycznie SQL-owymi systemami są zbyt duże, żeby możliwe było
 przeniesienie nawet względnie prostej aplikacji z jednego systemu na drugi.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/System_zarządzania_relacyjną_bazą_danych
\end_layout

\end_inset


\end_layout

\begin_layout Section
Diagram związków encji
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Diagram związków encji"
target "http://pl.wikipedia.org/wiki/P%C4%99tla_(informatyka)"

\end_inset


\end_layout

\begin_layout Standard
Diagram związków encji lub Diagram ERD (od ang.
 Entity-Relationship Diagram) – rodzaj graficznego przedstawienia związków
 pomiędzy encjami używany w projektowaniu systemów informacyjnych do przedstawie
nia konceptualnych modeli danych używanych w systemie.
\end_layout

\begin_layout Standard
Systemy CASE, które wspierają tworzenia tych diagramów, mogą na ich podstawie
 automatycznie tworzyć bazy danych odpowiadające relacjom na diagramie.
\end_layout

\begin_layout Standard
Diagram pokazuje logiczne związki pomiędzy różnymi encjami, związki te mają
 dwie cechy:
\end_layout

\begin_layout Standard
Opcjonalność – która mówi o tym, czy każda encja musi, czy też może wystąpić
 równocześnie z inną.
 Np.
 TOWAR musi zostać zakupiony przez co najmniej jednego KLIENTA, ale KLIENT
 może być nabywcą TOWARU.
 W reprezentacji graficznej linia przerywana oznacza opcjonalność związku,
 natomiast ciągła wymóg związku.
\end_layout

\begin_layout Standard
Krotność – określającą ile encji wchodzi w skład związku:
\end_layout

\begin_layout Standard
1:1 ("jeden do jeden") – encji odpowiada dokładnie jedna encja,
\end_layout

\begin_layout Standard
1:N ("jeden do wielu") – encji odpowiada jedna lub więcej encji,
\end_layout

\begin_layout Standard
M:N ("wiele do wielu") – jednej lub więcej encjom odpowiada jedna lub więcej
 encji.
\end_layout

\begin_layout Standard
W przypadku związków M:N często stosuje się normalizację diagramu, która
 polega na dodaniu encji pośredniczącej i zastąpienie związku M:N dwoma
 związkami 1:N z nową encją.
\end_layout

\begin_layout Section
Normalizacja baz danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Postać_normalna_(bazy_danych)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Postać normalna – postać relacji w bazie danych, w której nie występuje
 redundancja (nadmiarowość), czyli powtarzanie się tych samych informacji.
 Doprowadzeniu relacji do postaci normalnej służy normalizacja bazy danych.
 
\end_layout

\begin_layout Subsection*
Pierwsza postać normalna (1NF)
\end_layout

\begin_layout Standard
Relacja jest w pierwszej postaci normalnej, jeśli:
\end_layout

\begin_layout Itemize
opisuje jeden obiekt,
\end_layout

\begin_layout Itemize
wartości atrybutów są elementarne (atomowe, niepodzielne) - każda kolumna
 jest wartością skalarną (atomową), a nie macierzą lub listą czy też czymkolwiek
, co posiada własną strukturę,
\end_layout

\begin_layout Itemize
nie zawiera kolekcji (powtarzających się grup informacji),
\end_layout

\begin_layout Itemize
posiada klucz główny,
\end_layout

\begin_layout Itemize
kolejność wierszy może być dowolna (znaczenie danych nie zależy od kolejności
 wierszy).
\end_layout

\begin_layout Standard
Właściwości, które muszą zaistnieć w 1 formie :
\end_layout

\begin_layout Enumerate
Jest zdefiniowany klucz relacji.
\end_layout

\begin_layout Enumerate
Wszystkie atrybuty niekluczowe są w zależności funkcyjnej od klucza.
\end_layout

\begin_layout Subsection*
Druga postać normalna (2NF)
\end_layout

\begin_layout Standard
Relacja jest w drugiej postaci normalnej wtedy i tylko wtedy, gdy jest w
 I postaci normalnej i każda kolumna zależy funkcyjnie od całego klucza
 głównego (a nie np.
 od części klucza).
 
\end_layout

\begin_layout Subsection*
Trzecia postać normalna (3NF)
\end_layout

\begin_layout Standard
Mamy z nią do czynienia wtedy i tylko wtedy, gdy tabela jest w 2NF oraz
 gdy wszystkie pola niebędące polami klucza głównego są od niego zależne
 bezpośrednio.
\end_layout

\begin_layout Subsection*
Postać normalna Boyce'a-Codda (BCNF lub 3.5NF)
\end_layout

\begin_layout Standard
W tej postaci zależności funkcyjne muszą mieć następującą postać: jeżeli
 X → A i atrybut A nie jest zawarty w X, to X jest kluczem lub zawiera klucz.
 
\end_layout

\begin_layout Subsection*
Czwarta postać normalna (4NF)
\end_layout

\begin_layout Standard
Relacja jest w czwartej postaci normalnej, jeżeli zbiór atrybutów X określa
 wartościowo Y, to zachodzi jeden z następujących warunków (trywialne zależności
 wielowartościowe)
\end_layout

\begin_layout Itemize
Y jest puste lub zawiera się w X,
\end_layout

\begin_layout Itemize
suma zbiorów X i Y jest pełnym zbiorem atrybutów,
\end_layout

\begin_layout Itemize
X zawiera klucz.
\end_layout

\begin_layout Standard
Ponadto 4PN zachodzi wówczas gdy:
\end_layout

\begin_layout Itemize
spełnione są warunki PNB-C
\end_layout

\begin_layout Itemize
istnieją nietrywialne zależności gdzie Y wynika z X, X i Y są rozdzielne
 oraz X jest kluczem.
\end_layout

\begin_layout Standard
Czwarta i piąta postać normalna są w zasadzie używane wyłącznie przy okazji
 rozważań teoretycznych.
\end_layout

\begin_layout Section
Narzędzia typu CASE
\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: CASE"
target "http://pl.wikipedia.org/wiki/P%C4%99tla_(informatyka)"

\end_inset

 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia :: Narzędzia UML"
target "http://pl.wikipedia.org/wiki/Lista_narz%C4%99dzi_UML"

\end_inset


\end_layout

\begin_layout Section
Scharakteryzować wielowarstwowy model sieci komputerowej
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename model_osi_tcpip.tiff
	lyxscale 50
	scale 50
	groupId diagram

\end_inset


\end_layout

\begin_layout Subsection*
Model TCP/IP
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Model_TCP/IP
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Teoretyczny model warstwowej struktury protokołów komunikacyjnych.
 Model TCP/IP został stworzony w latach 70.
 XX wieku w DARPA, aby pomóc w tworzeniu odpornych na atak sieci komputerowych.
 Potem stał się podstawą struktury Internetu.
 
\end_layout

\begin_layout Standard
Podstawowym założeniem modelu TCP/IP jest podział całego zagadnienia komunikacji
 sieciowej na szereg współpracujących ze sobą warstw (ang.
 layers).
 Każda z nich może być tworzona przez programistów zupełnie niezależnie,
 jeżeli narzucimy pewne protokoły według których wymieniają się one informacjami.
 Założenia modelu TCP/IP są pod względem organizacji warstw zbliżone do
 modelu OSI.
 Jednak liczba warstw jest mniejsza i bardziej odzwierciedla prawdziwą strukturę
 Internetu.
 Model TCP/IP składa się z czterech warstw.
 
\end_layout

\begin_layout Subsubsection*
Warstwa aplikacji
\end_layout

\begin_layout Standard
Warstwa procesowa czy warstwa aplikacji (ang.
 process layer) to najwyższy poziom, w którym pracują użyteczne dla człowieka
 aplikacje takie jak np.
 serwer WWW czy przeglądarka internetowa.
 Obejmuje ona zestaw gotowych protokołów, które aplikacje wykorzystują do
 przesyłania różnego typu informacji w sieci.
 Wykorzystywane protokoły to m.in.: HTTP, Telnet, FTP, TFTP, SNMP, DNS, SMTP,
 X Windows.
 
\end_layout

\begin_layout Subsubsection*
Warstwa transportowa
\end_layout

\begin_layout Standard
Warstwa transportowa (ang.
 host-to-host layer) gwarantuje pewność przesyłania danych oraz kieruje
 właściwe informacje do odpowiednich aplikacji.
 Opiera się to na wykorzystaniu portów określonych dla każdego połączenia.
 W jednym komputerze może istnieć wiele aplikacji wymieniających dane z
 tym samym komputerem w sieci i nie nastąpi wymieszanie się przesyłanych
 przez nie danych.
 To właśnie ta warstwa nawiązuje i zrywa połączenia między komputerami oraz
 zapewnia pewność transmisji.
 
\end_layout

\begin_layout Subsubsection*
Warstwa Internetu
\end_layout

\begin_layout Standard
Warstwa Internetu lub warstwa protokołu internetowego (ang.
 internet protocol layer) to sedno działania Internetu.
 W tej warstwie przetwarzane są datagramy posiadające adresy IP.
 Ustalana jest odpowiednia droga do docelowego komputera w sieci.
 Niektóre urządzenia sieciowe posiadają tę warstwę jako najwyższą.
 Są to routery, które zajmują się kierowaniem ruchu w Internecie, bo znają
 topologię sieci.
 Proces odnajdywania przez routery właściwej drogi określa się jako trasowanie.
 
\end_layout

\begin_layout Subsubsection*
Warstwa dostępu do sieci
\end_layout

\begin_layout Standard
Warstwa dostępu do sieci lub warstwa fizyczna (ang.
 network access layer) jest najniższą warstwą i to ona zajmuje się przekazywanie
m danych przez fizyczne połączenia między urządzeniami sieciowymi.
 Najczęściej są to karty sieciowe lub modemy.
 Dodatkowo warstwa ta jest czasami wyposażona w protokoły do dynamicznego
 określania adresów IP.
 
\end_layout

\begin_layout Subsection*
Model OSI
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Model_OSI
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OSI (ang.
 Open System Interconnection) lub Model OSI (pełna nazwa ISO OSI RM, ang.
 ISO OSI Reference Model – model odniesienia łączenia systemów otwartych)
 – standard zdefiniowany przez ISO oraz ITU-T opisujący strukturę komunikacji
 sieciowej.
 
\end_layout

\begin_layout Standard
Model ISO OSI RM jest traktowany jako model odniesienia (wzorzec) dla większości
 rodzin protokołów komunikacyjnych.
 Podstawowym założeniem modelu jest podział systemów sieciowych na 7 warstw
 (ang.
 layers) współpracujących ze sobą w ściśle określony sposób.
 
\end_layout

\begin_layout Subsubsection*
Warstwa 7: aplikacji
\end_layout

\begin_layout Standard
Warstwa aplikacji jest warstwą najwyższą, zajmuje się specyfikacją interfejsu,
 który wykorzystują aplikacje do przesyłania danych do sieci (poprzez kolejne
 warstwy modelu ISO/OSI).
 W przypadku sieci komputerowych aplikacje są zwykle procesami uruchomionymi
 na odległych hostach.
 Interfejs udostępniający programistom usługi dostarczane przez warstwę
 aplikacji opiera się na obiektach nazywanych gniazdami (ang.
 socket).
 
\end_layout

\begin_layout Subsubsection*
Warstwa 6: prezentacji
\end_layout

\begin_layout Standard
Podczas ruchu w dół zadaniem warstwy prezentacji jest przetworzenie danych
 od aplikacji do postaci kanonicznej (ang.
 canonical representation) zgodnej ze specyfikacją OSI-RM, dzięki czemu
 niższe warstwy zawsze otrzymują dane w tym samym formacie.
 Kiedy informacje płyną w górę, warstwa prezentacji tłumaczy format otrzymywanyc
h danych na zgodny z wewnętrzną reprezentacją systemu docelowego.
 Wynika to ze zróżnicowania systemów komputerowych, które mogą w różny sposób
 interpretować te same dane.
 Dla przykładu bity w bajcie danych w niektórych procesorach są interpretowane
 w odwrotnej kolejności niż w innych.
 Warstwa ta odpowiada za kodowanie i konwersję danych oraz za kompresję
 / dekompresję; szyfrowanie / deszyfrowanie.
 Warstwa prezentacji obsługuje np.
 MPEG, JPG, GIF itp.
 
\end_layout

\begin_layout Subsubsection*
Warstwa 5: sesji
\end_layout

\begin_layout Standard
Warstwa sesji otrzymuje od różnych aplikacji dane, które muszą zostać odpowiedni
o zsynchronizowane.
 Synchronizacja występuje między warstwami sesji systemu nadawcy i odbiorcy.
 Warstwa sesji "wie", która aplikacja łączy się z którą, dzięki czemu może
 zapewnić właściwy kierunek przepływu danych – nadzoruje połączenie.
 Wznawia je po przerwaniu.
 
\end_layout

\begin_layout Subsubsection*
Warstwa 4: transportowa
\end_layout

\begin_layout Standard
Warstwa transportowa segmentuje dane oraz składa je w tzw.
 strumień.
 Warstwa ta zapewnia całościowe połączenie między stacjami: źródłową oraz
 docelową, które obejmuje całą drogę transmisji.
 Następuje tutaj podział danych na części, które są kolejno numerowane i
 wysyłane do docelowej stacji.
 Na poziomie tej warstwy do transmisji danych wykorzystuje się dwa protokoły
 TCP (ang.
 Transmission Control Protocol) oraz UDP (ang.
 User Datagram Protocol).
\end_layout

\begin_layout Subsubsection*
Warstwa 3: sieciowa
\end_layout

\begin_layout Standard
Warstwa sieciowa jako jedyna dysponuje wiedzą dotyczącą fizycznej topologii
 sieci.
 Rozpoznaje, jakie drogi łączą poszczególne komputery (trasowanie) i decyduje,
 ile informacji należy przesłać jednym z połączeń, a ile innym.
 Jeżeli danych do przesłania jest zbyt wiele, to warstwa sieciowa po prostu
 je ignoruje.
 Nie musi zapewniać pewności transmisji, więc w razie błędu pomija niepoprawne
 pakiety danych.
 Standardowa paczka danych czasami oznaczana jest jako NPDU (ang.
 Network Protocol Data Unit).
 Nie znajdują się w nim żadne użyteczne dla użytkowników aplikacje.
 Jedyne jego zadanie, to zapewnienie sprawnej łączności między bardzo odległymi
 punktami sieci.
 Routery są podstawą budowy rozległych sieci informatycznych takich jak
 Internet, bo potrafią odnaleźć najlepszą drogę do przekazania informacji.
 Warstwa sieciowa podczas ruchu w dół umieszcza dane wewnątrz pakietów zrozumiał
ych dla warstw niższych (kapsułkowanie).
 Jednocześnie warstwa sieci używa czterech procesów (adresowanie, enkapsulacja,
 routing, dekapsulacja).
 Protokoły warstwy sieci to: (IPv4, IPv6, ICMP, NOVELL IPX, APPLE TALK,
 CLNS/DECN et).
 
\end_layout

\begin_layout Subsubsection*
Warstwa 2: łącza danych
\end_layout

\begin_layout Standard
Warstwa łącza danych jest czasami nazywana warstwą liniową lub kanałową.
 Ma ona nadzorować jakość przekazywanych informacji.
 Nadzór ten dotyczy wyłącznie warstwy niższej.
 Warstwa łącza danych ma możliwość zmiany parametrów pracy warstwy fizycznej,
 tak aby obniżyć liczbę pojawiających się podczas przekazu błędów.
 Zajmuje się pakowaniem danych w ramki i wysyłaniem do warstwy fizycznej.
 Rozpoznaje błędy związane z niedotarciem pakietu oraz uszkodzeniem ramek
 i zajmuje się ich naprawą.
 Podczas ruchu w dół w warstwie łącza danych zachodzi enkapsulacja pakietów
 z warstwy sieciowej tak, aby uzyskać ramki zgodne ze standardem.
 Czasami są one oznaczane jako LPDU (ang.
 data Link Protocol Data Unit).
 
\end_layout

\begin_layout Section
Przedstawić klasyfikację sieci komputerowych
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Lan networks"
target "http://lan-networks.cba.pl/Klasyfikacja.html"

\end_inset


\end_layout

\begin_layout Standard
Podział sieci ze względu na obejmowany obszar:
\end_layout

\begin_layout Itemize
lokalna sieć (LAN - Local Area Network) - łączy stacje robocze na niewielkim
 obszarze(pomieszczenie, piętro, budynek), charakteryzuje się niskimi kosztami
 eksploatacji oraz dołączania kolejnych komputerów oraz prostym oprogramowaniem.
\end_layout

\begin_layout Itemize
sieć kampusowa (Campus Network) - obejmuje zasięgiem kilka budynków na terenie
 uczelni, firmy lub osiedla.
\end_layout

\begin_layout Itemize
miejska sieć (MAN - Metropolitan Area Network)- integruje sieci LAN na obszarze
 całego miasta , oparta jest na laczach o duzej przepustowości np.
 na światłowodach.
\end_layout

\begin_layout Itemize
rozległa sieć (WAN - Wide Area network) - łączy wiele sieci typu MAN i WAN
 na dużych terenach geograficznych np.
 region, państwo, kontynent.
 Wykorzystuje publiczną sieć telekomunikacyjną ale w wielu przypadkach również
 kanały satelitarne lub radiowe.
\end_layout

\begin_layout Itemize
sieć radiowa (Radio Network) sieć do której łączenia nie korzysta się z
 przewodów, do każdej stacji dołączany jest nadajnik - odbiornik, zasięg
 takich sieć jest być uwarunkowany mocą nadajniko-odbiorników
\end_layout

\begin_layout Itemize
sieć satelitarna (Satellite Network) sieć, w której sygnały przekazywane
 są ze stacji naziemnej do satelity i z satelity do innej stacji naziemnej,
 sygnał jest wzmacniany w Satelicie.
\end_layout

\begin_layout Section
Omówić podstawowe narzędzia administratora sieci komputerowej
\end_layout

\begin_layout Subsection*
ping
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Ping
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ping — nazwa programu używanego w sieciach komputerowych TCP/IP (takich
 jak Internet) służącego do diagnozowania połączeń sieciowych.
 Pozwala na sprawdzenie czy istnieje połączenie pomiędzy hostami testującym
 i testowanym.
 Umożliwia on zmierzenie liczby zgubionych pakietów oraz opóźnień w ich
 transmisji, zwanych lagami.
 
\end_layout

\begin_layout Subsection*
traceroute
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Traceroute
\end_layout

\end_inset


\end_layout

\begin_layout Standard
traceroute - program służący do badania trasy pakietów w sieci IP.
 Program traceroute jest szeroko dostępny we wszystkich uniksowych systemach
 operacyjnych; jest także dostępny program mtr, który łączy funkcjonalność
 traceroute z narzędziem ping.
 Istnieje również program tracert o podobnej funkcjonalności, zawarty w
 systemach z rodziny Microsoft Windows.
 
\end_layout

\begin_layout Subsection*
route
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Route
\end_layout

\end_inset


\end_layout

\begin_layout Standard
route – program narzędziowy w systemach uniksowych oraz Windows, który wyświetla
 i umożliwia zmiany tablicy trasowania pakietów sieciowych.
 
\end_layout

\begin_layout Subsection*
ip
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Ip_(Linux)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ip - polecenie do konfiguracji interfejsów sieciowych, tablic tras czy tuneli
 w systemach operacyjnych Linux.
 W pełni wspiera protokoły IPv4 i IPv6, działa też z gniazdami BSD.
 Polecenie wchodzi w skład pakietu Iproute2 - narzędzi do zarządzania siecią
 i kontroli ruchu sieciowego (QoS) w systemach Linux.
 Iproute2 zastępuje starsze narzędzia ifconfig czy route jeszcze zachowane
 w dystrybucjach dla kompatybilności.
 
\end_layout

\begin_layout Subsection*
iptables
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Iptables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
iptables to program sterujący filtrem pakietów (głównie używanym jako zapora
 sieciowa bądź NAT) opracowany dla systemu operacyjnego Linux.
\end_layout

\begin_layout Standard
Program może być używany jako filtr pakietów, bądź tzw.
 stanowa zapora dla systemów Linux z jądrem począwszy od serii 2.4.x, kontrolujący
 połączenia wchodzące i wychodzące do sieci komputerowej lub stacji roboczej.
\end_layout

\begin_layout Section
Scharakteryzować politykę bezpieczeństwa w systemach komputerowych
\end_layout

\begin_layout Standard
Środki do zabezpieczania systemów informacyjnych i sieci:
\end_layout

\begin_layout Itemize
Techniczne: kopie zapasowe, odtwarzanie po awariach, konfiguracja systemu
 operacyjnego i baz danych, aktualizacja oprogramowania, itp.,
\end_layout

\begin_layout Itemize
Kryptograficzne: poufność, integralność, niemożność zaprzeczenia.
\end_layout

\begin_layout Itemize
Kryptograficzne i systemowe: autoryzacja, audyt, uwierzytelnianie.
\end_layout

\begin_layout Itemize
Kryptograficzne, protokolarne, usługowe: śluzy ogniowe, tunelowanie, zabezpiecze
nia sieci TCP/IP: IP i IPSEC, SSL/TSL, https, ssh, itp.
\end_layout

\begin_layout Itemize
Uwierzytelnianie i identyfikacja w sieciach: karty inteligentne, KERBEROS,
 DCE, SESAME, i inne.
\end_layout

\begin_layout Section
Wyjaśnij terminy: identyfikacja, uwierzytelnienie, autoryzacja, spójność
 danych, ślad kontroli
\end_layout

\begin_layout Subsection*
Identyfikacja
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Uwierzytelnianie
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podmiot deklaruje swoją tożsamość.
\end_layout

\begin_layout Subsection*
Uwierzytelnianie
\end_layout

\begin_layout Standard
Strona ufająca stosuje odpowiednią technikę uwierzytelniania (authentication
 mechanism) w celu weryfikacji zadeklarowanej wcześniej tożsamości.
\end_layout

\begin_layout Subsection*
Autoryzacja
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Autoryzacja_(informatyka)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Potwierdzenie, czy dany podmiot jest uprawniony do uzyskania dostępu do
 żądanego zasobu.
 Na tym etapie autentyczność podmiotu jest już potwierdzona, nie musi on
 jednak być uprawnionym do uzyskania dostępu w żądanym zakresie.
\end_layout

\begin_layout Standard
Celem autoryzacji jest kontrola dostępu (access control), która potwierdza,
 czy dany podmiot jest uprawniony do korzystania z żądanego zasobu.
 Dla określenia uprawnień danego podmiotu konieczne jest najpierw stwierdzenie
 jego tożsamości, dlatego w typowym zastosowaniu autoryzacja następuje dopiero
 po potwierdzeniu tożsamości podmiotu za pomocą identyfikacji i uwierzytelnienia.
 
\end_layout

\begin_layout Subsection*
Integralność danych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Integralność_danych
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funkcja bezpieczeństwa polegająca na tym, że dane nie zostały zmienione,
 dodane lub usunięte w nieautoryzowany sposób.
\end_layout

\begin_layout Standard
W technice informatycznej i telekomunikacyjnej ochrona integralności zapobiega
 przypadkowemu zniekształceniu danych podczas odczytu, zapisu, transmisji
 lub magazynowania.
 Wykorzystuje się tutaj sumy kontrolne i kody korekcyjne takie jak CRC.
 
\end_layout

\begin_layout Standard
W bezpieczeństwie teleinformatycznym ochrona integralności zapobiega celowej
 modyfikacji danych dokonanej z użyciem zaawansowanych technik, mających
 na celu ukrycie faktu dokonania zmiany.
 Wykorzystuje się tutaj techniki kryptograficzne takie jak kody MAC odporne
 na celowe manipulacje.
 W odniesieniu do relacyjnych baz danych integralność definiowana jest jako
 połączenie trzech koncepcji: dokładność (ang.
 accuracy), prawdziwość (ang.
 correctness), oraz aktualność (ang.
 validity).
 
\end_layout

\begin_layout Subsection*
Ślad kontroli
\end_layout

\begin_layout Standard
System przechowuje historię operacji dokonywanych przez użytkowników.
 
\end_layout

\begin_layout Section
[TODO] Scharakteryzować komponenty zintegrowanych programów bezpieczeństwa
 w systemach komputerowych
\end_layout

\begin_layout Standard
WTF?
\end_layout

\begin_layout Section
Podstawowe modele kontroli dostępu do systemów operacyjnych i baz danych.
\end_layout

\begin_layout Paragraph*
DAC
\end_layout

\begin_layout Standard
określa podstawowe metody kontroli dostępu do obiektów w systemie plików.
 Administratorem uprawnień jest sysadmin lub właściciel obiektu (pliku).
 Rozbudowana wersją DAC jest model ACL – list kontroli dostępu.
\end_layout

\begin_layout Paragraph*
MAC
\end_layout

\begin_layout Standard
ochrania i zabezpiecza procesy, dane i urządzenia systemowe przed szkodliwym
 nadużyciem/wykorzystaniem za pomocą tzw.
 etykiet.
 Właściciel obiektu po jego utworzeniu może nie mieć prawa do późniejszego
 np.
 odczytu!
\end_layout

\begin_layout Paragraph*
RBAC
\end_layout

\begin_layout Standard
ogranicza dostęp do zasobów na podstawie roli, jaką użytkownik pełni w systemie.
 Przystosowany do organizacji, w której działa.
 Ukierunkowany na czynności użytkownika.
 Może wykorzystywać DAC, MAC i inne modele.
\end_layout

\begin_layout Paragraph*
przejmij - przekaż
\end_layout

\begin_layout Itemize
Rozszerzenie modelu macierzowego (DAC) – ujmuje kwestie delegacji i przejmowania
 uprawnień.
\end_layout

\begin_layout Itemize
Informacja o uprawnieniach jest pamiętana w postaci grafu, który opisuje
 wszystkie powiązania dot.
 przepływu informacji.
\end_layout

\begin_layout Itemize
Podmiot ma (w tym modelu!) uprawnienia do obiektu albo innego podmiotu.
\end_layout

\begin_deeper
\begin_layout Itemize
Przekaż - podmiot x przekazuje uprawnienie h, jakie ma do z (obiektu lub
 podmiotu), obiektowi lub podmiotowi y pod warunkiem, że x ma uprawnienie
 g do przekazywania uprawnień.
\end_layout

\begin_layout Itemize
Przejmij - podmiot x przekazuje uprawnienie h (pozbywając się uprawnienia
 h do obiektu z), jakie ma do z (obiektu lub podmiotu), obiektowi lub podmiotowi
 y pod warunkiem, że y ma uprawnienie t do przejęcia uprawnień.
\end_layout

\end_deeper
\begin_layout Paragraph*
Wooda
\end_layout

\begin_layout Standard
Skierowany na realizację polityki bezpieczeństwa w środowisku baz danych.
\end_layout

\begin_layout Itemize
poziomy
\end_layout

\begin_deeper
\begin_layout Itemize
Zewnętrzny,
\end_layout

\begin_layout Itemize
Konceptualny,
\end_layout

\begin_layout Itemize
Wewnętrzny.
\end_layout

\end_deeper
\begin_layout Itemize
podmioty to:
\end_layout

\begin_deeper
\begin_layout Itemize
Użytkownicy,
\end_layout

\begin_layout Itemize
administratorzy uprawnień.
\end_layout

\end_deeper
\begin_layout Itemize
obiekty to 
\end_layout

\begin_deeper
\begin_layout Itemize
tablice bazy danych
\end_layout

\begin_layout Itemize
kolumny tablic
\end_layout

\begin_layout Itemize
tablice wirtualne (widoki)
\end_layout

\begin_layout Itemize
ew.
 funkcje.
\end_layout

\end_deeper
\begin_layout Itemize
Dla poziomu zewnętrznego i konceptualnego są definiowane reguły dostępu,
 które muszą być niesprzeczne.
\end_layout

\begin_layout Paragraph*
Jajodhi-Sadhu
\end_layout

\begin_layout Standard
Kontrola dostępu MAC dla baz danych.
\end_layout

\begin_layout Itemize
Do modelu relacyjnego są wprowadzone atrybuty klasyfikacyjne zw.
 etykietami bezpieczeństwa: jawny < poufny < tajny < ściśle tajny
\end_layout

\begin_layout Itemize
Schemat relacyjny wielopoziomowy: Każdy atrybut oprócz wartości ma nadany
 atrybut klasyfikacyjny, a ponadto cała krotka ma również taki atrybut.
\end_layout

\begin_layout Itemize
Polityka bezpieczeństwa to kontrola dostępu do realizacji operacji typu
 dołącz, aktualizuj, usuń na relacjach wielopoziomowych.
\end_layout

\begin_layout Section
Porównanie kryptografii symetrycznej i asymetrycznej
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle" tabularwidth="90text%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cecha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symetryczne
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Asymetryczne
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Klucz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ten sam klucz do szyfrowania i deszyfrowania
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jeden klucz do szyfrowania, a inny (drugi do pary) do deszyfracji 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Długość klucza
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
typowo: 112-128 bitów
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
do 4096 bitów i niekiedy więcej
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Szybkość szyfrowania
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dziesiątki Gb/s, a kilkaset razy wolniej dla realizacji programowych
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100-1000 razy wolniej od realizacji programowych dla alg.
 symetrycznych
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podstawy teoretyczne
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
szyfry podstawieniowe i przestawieniowe, przekształcenia jednokierunkowe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
arytmetyka modulo n, logarytmy dyskretne i inne problemy obliczeniowe NP-zupełne
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Główne zastosowania
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
zabezpieczanie łączy komunikacyjnych, transmisja danych i uwierzytelnianie
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
podpisy cyfrowe, wymiana i dystrybucja kluczy do transmisji danych (symetrycznyc
h), uwierzytelnianie, gotówka cyfrowa, podpisywanie kontraktów i inne protokoły
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Scharakteryzować podpis elektroniczny
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Podpis_cyfrowy
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Matematyczny sposób potwierdzania autentyczności cyfrowego dokumentu.
 Istnieje wiele schematów podpisów cyfrowych, obecnie jednak najpopularniejszym
 jest schemat podpisu dokumentów cyfrowych w systemach kryptograficznych
 z kluczem publicznym i jednokierunkową funkcją skrótu - w systemie tym
 do oryginalnej wiadomości dołączany jest skrót dokumentu, zaszyfrowany
 prywatnym kluczem nadawcy.
 Potwierdzenie autentyczności wiadomości jest możliwe po odszyfrowaniu skrótu
 kluczem publicznym nadawcy i porównaniu go z wytworzonym skrótem odebranego
 dokumentu.
\end_layout

\begin_layout Section
Charakterystyka protokołów uwierzytelniania
\end_layout

\begin_layout Itemize
w jakim celu stosujemy:
\end_layout

\begin_deeper
\begin_layout Itemize
chroni dokument przed podrobieniem,
\end_layout

\begin_layout Itemize
TTP może ocenić i zadecydować o ważności dokumentu (metody symetryczne).
\end_layout

\end_deeper
\begin_layout Itemize
2 podstawowe sposoby:
\end_layout

\begin_deeper
\begin_layout Itemize
symetryczne - w obrębie grupy osób, które sobie ufają,
\end_layout

\begin_layout Itemize
asymetryczne (za pomocą podpisów cyfrowych).
\end_layout

\end_deeper
\begin_layout Itemize
Uwierzytelnianie symetryczne - technologia: wiarygodność źródła (pochodzenia)
 informacji jest zastępowana przez obliczenie skrótu informacji i kryptograficzn
ą ochronę tego skrótu - możliwości:
\end_layout

\begin_deeper
\begin_layout Itemize
utajnienie algorytmu skrótu albo
\end_layout

\begin_layout Itemize
utajnienie wartości skrótu albo
\end_layout

\begin_layout Itemize
autentyczność wartości skrótu (nie jest to klasyczny podpis).
\end_layout

\end_deeper
\begin_layout Subsection
uwierzytelnianie symetryczne
\end_layout

\begin_layout Itemize
Podstawowy protokół symetryczny:
\end_layout

\begin_deeper
\begin_layout Itemize
A wysyła do B: M, EK(H(M)), gdzie: K – klucz współdzielony przez A i B,
 H(M) – skrót wiadomości M,
\end_layout

\begin_layout Itemize
B oblicza z M skrót H(M) i porównuje z DK(EK(H(M)));
\begin_inset Newline newline
\end_inset

jeśli oba skróty są zgodne, to wiadomość jest autentyczna (wiarygodna).
\end_layout

\end_deeper
\begin_layout Itemize
Obliczanie skrótu wiadomości - podstawowe techniki:
\end_layout

\begin_deeper
\begin_layout Itemize
MDC - Message Digest Cipher - funkcje skrótu bezkluczowe - muszą być dobrej
 jakości;
\end_layout

\begin_layout Itemize
MAC - Message Authentication Code - skrót z tajnym kluczem K może być wytworzony
 przez kogoś, kto zna K.
\end_layout

\end_deeper
\begin_layout Itemize
nie wolno stosować tego samego klucza do MAC i do szyfrowania danych!!!
\end_layout

\begin_layout Itemize
jako funkcji skrótu można użyć:
\end_layout

\begin_deeper
\begin_layout Itemize
dowolnego dobrego szyfru blokowego w trybie np.
 CBC z wektorem inicjalnym IV=0, bo obliczamy skrót!
\end_layout

\begin_layout Itemize
inne popularne algorytmy MAC to:
\end_layout

\begin_deeper
\begin_layout Itemize
CBC-MAC (DES w trybie CBC - MAC to 32 pierwsze bity wyniku)
\end_layout

\begin_layout Itemize
HMAC: h(( K+p2 ), h(( K+p1 ), x), gdzie pi to ustalone łańcuchy, h to np.
 funkcja RIPEMD-160
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
W przypadku MDC skrót jest szyfrowany za pomocą klucza tajnego (współdzielonego
 przez grupę użytkowników lub przez użytkownika i TTP) dla algorytmu symetryczne
go.
 Dla MAC może jeszcze wystąpić dodatkowe szyfrowanie, ale nie musi.
\end_layout

\begin_layout Itemize
Problemy - ograniczone zastosowania, duża liczba kluczy
\end_layout

\begin_layout Subsection
uwierzytelnianie asymetryczne
\end_layout

\begin_layout Itemize
Podstawowa technika - podpisy cyfrowe.
 Zasadniczo nie podpisuje się całych wiadomości, Dlaczego?
\end_layout

\begin_deeper
\begin_layout Itemize
czas realizacji podpisu,
\end_layout

\begin_layout Itemize
możliwość ataków, gdy podpisywane wiadomości są krótkie (RSA).
\end_layout

\end_deeper
\begin_layout Itemize
Realizacja podpisu Alice:
\end_layout

\begin_deeper
\begin_layout Standard
S A = E Kp (H(M)); do wysłania dodatkowo można go zaszyfrować razem z wiadomości
ą ( Kp to klucz prywatny Alice); ale na ogół wysyłamy: M, SA
\end_layout

\end_deeper
\begin_layout Itemize
Pytanie: jak weryfikujemy podpis? (co musi zrobić Bob, aby sprawdzić poprawność
 podpisu?) Czego używamy? Jaka jest ewentualna rola TTP?
\end_layout

\begin_layout Itemize
Problemy:
\end_layout

\begin_deeper
\begin_layout Itemize
zarządzanie kluczami publicznymi,
\end_layout

\begin_layout Itemize
słabości niektórych algorytmów.
\end_layout

\end_deeper
\begin_layout Itemize
Stosowane algorytmy: RSA (1978), ElGamal(1985), DSA(1994)
\end_layout

\begin_layout Itemize
Przyszłość: algorytmy oparte na logarytmie dyskretnym w obrębie grupy krzywych
 eliptycznych w ciele Galois GF(p),
\end_layout

\begin_layout Itemize
Zaleta: krótsze klucze - ok.
 200 bitów w stos.
 do 1024 (RSA)
\end_layout

\begin_layout Section
Omówić cechy systemów rozproszonych
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/System_rozproszony
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To zbiór niezależnych urządzeń technicznych połączonych w jedną, spójną
 logicznie całość.
 Zwykle łączonymi urządzeniami są komputery, rzadziej – systemy automatyki.
 Połączenie najczęściej realizowane jest przez sieć komputerową, jednak
 można wykorzystać również inne – prostsze – magistrale komunikacyjne.
 Urządzenia są wyposażone w oprogramowanie umożliwiające współdzielenie
 zasobów systemowych.
 
\end_layout

\begin_layout Enumerate
Dzielenie zasobów (ang.
 resource sharing) – wielu użytkowników systemu może korzystać z danego
 zasobu (np.
 drukarek, plików, usług, itp.).
\end_layout

\begin_layout Enumerate
Otwartość (ang.
 openness) – podatność na rozszerzenia, możliwość rozbudowy systemu zarówno
 pod względem sprzętowym, jak i oprogramowania.
\end_layout

\begin_layout Enumerate
Współbieżność (ang.
 concurrency) – zdolność do przetwarzania wielu zadań jednocześnie.
\end_layout

\begin_layout Enumerate
Skalowalność (ang.
 scalability) – cecha systemu umożliwiająca zachowanie podobnej wydajności
 systemu przy zwiększaniu skali systemu (np.
 liczby procesów, komputerów, itp.).
\end_layout

\begin_layout Enumerate
Tolerowanie awarii (ang.
 fault tolerance) – właściwość systemu umożliwiająca działania systemu mimo
 pojawiania się błędów i (lub) uszkodzeń (np.
 przez utrzymywanie nadmiarowego sprzętu).
\end_layout

\begin_layout Enumerate
Przezroczystość (ang.
 transparency) – właściwość systemu powodująca postrzeganie systemu przez
 użytkownika jako całości, a nie poszczególnych składowych.
\end_layout

\begin_layout Section
Scharakteryzować przykładowe architektury systemów rozproszonych
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://docs.google.com/viewer?a=v&q=cache:Hxl3mw6e9l8J:janek.ae.krakow.pl/~wiluszt/A
E/SK/cwiczenia/cwicz02/sysrozp.pdf+&hl=pl&gl=pl&pid=bl&srcid=ADGEESg6Cd6RogQ3VVZ6
KN3QVt_mycruht4ZKFXeo247dUWi7XG38ESkadu8QJ568wNh1vvTR2Ofxrd02s8D6V8Njr8yJdx_5Cz9
JALxHGwyXGuRhRmaDJuxKAGdkJ0t6lAFd1hjPPpw&sig=AHIEtbR5uzsaK_cxyOkuBEGbAciwuaSohw
\end_layout

\end_inset


\end_layout

\begin_layout Description
Klient-serwer: rozproszony system ma wyróżniony węzeł zwany serwerem, oraz
 szereg podłączonych do niego węzłów zwanych klientami.
\end_layout

\begin_deeper
\begin_layout Itemize
Związek nie jest symetryczny: serwer wykonuje usługi zlecane przez klientów,
 nie może im odmówić i nie może im zlecić wykonanie usług.
\end_layout

\end_deeper
\begin_layout Description
Klient-multi-serwer: podobnie jak dla architektury klient-serwer, ale istnieje
 wiele serwerów, np.
 WWW.
\end_layout

\begin_layout Description
Koleżeńska (peer-to-peer, P2P): wiele węzłów świadczy sobie wzajemne usługi
 poprzez bezpośrednie połączenie; nie ma wyraźnego podziału na usługodawców
 i usługobiorców.
\end_layout

\begin_deeper
\begin_layout Itemize
Np.
 Gnutella, NXOR, Napster, Kazaa; JXTA jako narzędzie do P2P.
\end_layout

\begin_layout Itemize
Komercyjny buzz dookoła P2P.
\end_layout

\end_deeper
\begin_layout Description
Architektura
\begin_inset space ~
\end_inset

oparta
\begin_inset space ~
\end_inset

na
\begin_inset space ~
\end_inset

oprogramowaniu
\begin_inset space ~
\end_inset

pośredniczącym
\begin_inset space ~
\end_inset

(middleware): nie występuje podział na klientów i serwery, np.
 CORBA i WebServices.
\end_layout

\begin_layout Description
Architektury
\begin_inset space ~
\end_inset

gridowe: wirtualny komputer sumujący zasoby wielu komputerów w sposób przezroczy
sty dla użytkowników.
\end_layout

\begin_layout Section
Porównać technologie CORBA i JAVA RMI
\end_layout

\begin_layout Subsection*
Common Object Request Broker Architecture
\end_layout

\begin_layout Standard
Technologia zapewniająca komunikację pomiędzy obiektami pracującymi w heterogeni
cznych (różnorodnych) systemach komputerowych.
 Obiekty pełniące dowolne funkcje mogą być zaimplementowane w różnych językach
 programowania, na dowolnej platformie sprzętowej, pod kontrolą różnych
 systemów operacyjnych.
 
\end_layout

\begin_layout Standard
Opis obiektów, a właściwie interfejsów do nich, znajduje się w pliku IDL
 (ang.
 Interface Definition Language), który jest kompilowany na kod zajmujący
 się przekazywaniem metod (w przypadku implementacji technologii CORBA w
 niektórych językach interpretowanych, plik IDL jest interpretowany w czasie
 wykonania).
 
\end_layout

\begin_layout Standard
Obiekty mają swoje adresy IOR (ang.
 Interoperable Object Reference).
 Są to kilkusetznakowe adresy kodujące wiele informacji o obiekcie, m.in.
 adres komputera, adres programu na komputerze, informacje o kolejności
 zapisu bajtów (czy jest to big endian, czy little endian), numer obiektu,
 typ obiektu, itd.
 
\end_layout

\begin_layout Standard
Adresy IOR mogą dotyczyć także niskopoziomowych protokołów transmisji danych
 – zwykle GIOP (ang.
 General Inter-ORB Protocol) lub IIOP (ang.
 Internet Inter-ORB Protocol).
 
\end_layout

\begin_layout Subsection*
Remote Method Invocation
\end_layout

\begin_layout Standard
To mechanizm umożliwiający zdalne wywołanie metod obiektów.
 Obiekty te mogą znajdować się w innych maszynach wirtualnych Javy, które
 mogą znajdować się na innych komputerach.
 
\end_layout

\begin_layout Standard
Obiekty zdalne rejestrowane są pod wybranymi nazwami w serwisie RMI Registry.
 Aplikacja kliencka ściąga z RMI Registry tzw.
 stub tego obiektu, który umożliwia komunikację z obiektem zdalnym przy
 użyciu wyeksportowanych metod w ten sam sposób, jakby chodziło o obiekt
 lokalny.
 Rola RMI Registry w tym miejscu kończy się - nie pośredniczy on w komunikacji
 pomiędzy aplikacją kliencką a obiektem zdalnym.
 Parametry metod będące obiektami przy wywołaniu zdalnym są serializowane.
 
\end_layout

\begin_layout Section
Omówić usługi nazewnicze i role rejestrów w systemach rozproszonych
\end_layout

\begin_layout Standard
To je to:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://docs.google.com/viewer?a=v&q=cache:aDO_4hY_WRwJ:www.eti.pg.gda.pl/katedry/kask
/pracownicy/Michal.Piotrowski/sr-pliki/wyklad02.pdf+&hl=pl&gl=pl&pid=bl&srcid=ADGE
ESjOBQumrjyD-YSwtzguaCcxZswJGRuuFomMYqXJmmXiMRwVS9ekha2zNRZHtldh8t_j1LNF00VdDZAQ
5cyZ884by9nvbVDCWJ8WRyuCX8MfAsDhhHrEG9pvtzoOgOd9DP-lwEsv&sig=AHIEtbRzxNNjCrBOLpO
51NcKkza3juxWZQ
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sklasyfikować i omówić języki programowania serwisów Internetowych
\end_layout

\begin_layout Subsection*
PHP
\end_layout

\begin_layout Subsection*
Java
\end_layout

\begin_layout Subsection*
C#
\end_layout

\begin_layout Subsection*
Ruby
\end_layout

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Subsection*
Lisp
\end_layout

\begin_layout Subsection*
Perl
\end_layout

\begin_layout Subsection*
Python
\end_layout

\begin_layout Subsection*
ColdFusion
\end_layout

\begin_layout Subsection*
Visual Basic
\end_layout

\begin_layout Subsection*
JavaScript
\end_layout

\begin_layout Subsection*
C++
\end_layout

\begin_layout Subsection*
Clojure
\end_layout

\begin_layout Standard
???
\end_layout

\begin_layout Section
Scharakteryzować język PHP
\end_layout

\begin_layout Standard
Wykonywany po stronie serwera.
\end_layout

\begin_layout Standard
Nie posiada kompilatora, ani maszyny wirtualnej, tylko intepreter.
 
\end_layout

\begin_layout Standard
Tylko interpreter może wykonać skrypt.
\end_layout

\begin_layout Standard
Nie jest typowany statycznie, ale można sprawdzać typy i rzutować.
\end_layout

\begin_layout Standard
GC po zakończeniu skryptu.
\end_layout

\begin_layout Standard
Zaczynał jako język strukturalny, pełną obiektowość osiągnął w wersji 5.
\end_layout

\begin_layout Standard
Od wersji 5.3 posiada wsparcie dla programowania funkcyjnego (wyrażenia lambda
 i funkcje anonimowe)
\end_layout

\begin_layout Section
Wymienić i krótko omówić instrukcje sterujące w PHP
\end_layout

\begin_layout Subsection*
elseif/else if
\end_layout

\begin_layout Standard
Wybrany blok kodu jest wykonywany w zależności od wartości wyrażenia logicznego.
\end_layout

\begin_layout Subsection*
while
\end_layout

\begin_layout Standard
Wykonywanie bloku kodu jest powtarzane dopóki wartość wyrażenie logicznego
 jest prawdą.
\end_layout

\begin_layout Subsection*
do-while
\end_layout

\begin_layout Standard
Jak pętla 
\emph on
while
\emph default
 ale najpierw jest wykonywana jedna iteracja, a dopiero po jej zakończeniu
 jest sprawdzana wartość wyrażenie logicznego decydującego o zakończeniu
 iteracji.
\end_layout

\begin_layout Subsection*
for
\end_layout

\begin_layout Standard
Służy do budowania pętli bazujących na zmiennych sterujących o danej wartości
 startowej, wyrażeniu logicznego decydującego o zakończeniu iteracji oraz
 bloku zmieniającego wartość zmiennych sterujących.
\end_layout

\begin_layout Subsection*
foreach
\end_layout

\begin_layout Standard
Ułatwia iteracje po wartościach przechowywanych w tablicach.
\end_layout

\begin_layout Subsection*
break
\end_layout

\begin_layout Standard
Kończy wykonywanie instrukcji 
\emph on
for
\emph default
, 
\emph on
foreach
\emph default
, 
\emph on
while
\emph default
, 
\emph on
do-while
\emph default
 lub 
\emph on
switch
\emph default
.
 Przyjmuje parametr określający liczbę zagnieżdżonych instrukcji których
 wykonywanie kończy.
\end_layout

\begin_layout Subsection*
continue
\end_layout

\begin_layout Standard
Wykorzystywane jest do zakończenia przetwarzania obecnie wykonywanej pętli
 
\emph on
while
\emph default
, 
\emph on
do-while
\emph default
, for lub 
\emph on
foreach
\emph default
 i przejścia do wykonania następnej iteracji.
\end_layout

\begin_layout Subsection*
switch
\end_layout

\begin_layout Standard
Podobne do 
\emph on
if
\emph default
, użyteczne tam gdzie chcemy porównać wartość jednej zmiennej z wieloma
 innymi wartościami i uruchomić inny blok kodu w zależności od tego z którą
 wartością zmienna się równa.
\end_layout

\begin_layout Subsection*
declare
\end_layout

\begin_layout Standard
Umożliwia ustawianie dyrektyw wykonywalnych dla bloku kodu PHP.
 Podstawową dyrektywą jest dyrektywa 
\emph on
encoding
\emph default
 umożliwiająca zmianę kodowania znaków.
 Dyrektywa 
\emph on
tick
\emph default
 jest pomocna przy profilowaniu kodu.
\end_layout

\begin_layout Subsection*
return
\end_layout

\begin_layout Standard
Kończy wywołanie funkcji.
 Wartość podana jako argument do instrukcji 
\emph on
return
\emph default
 jest wartością zwracaną przez funkcję której wywołanie kończy.
\end_layout

\begin_layout Subsection*
require
\end_layout

\begin_layout Standard
To to samo co 
\emph on
include
\emph default
 ale w razie błędu powoduje zakończenie działania skryptu z błędem.
\end_layout

\begin_layout Subsection*
include
\end_layout

\begin_layout Standard
Załącza i wykonuje kod PHP znajdujący się we wskazanym pliku.
\end_layout

\begin_layout Subsection*
require_once
\end_layout

\begin_layout Standard
To samo co 
\emph on
require
\emph default
 ale nie wykonywane jest ponownie jeżeli już dany plik został załadowany.
\end_layout

\begin_layout Subsection*
include_once
\end_layout

\begin_layout Standard
To samo co 
\emph on
include
\emph default
 ale nie wykonywane jest ponownie jeżeli już dany plik został załadowany.
\end_layout

\begin_layout Subsection*
goto
\end_layout

\begin_layout Standard
Umożliwia przełączenie punktu wykonywania kodu do innego miejsca programu.
\end_layout

\begin_layout Section
Scharakteryzować język JavaScript
\end_layout

\begin_layout Standard
Wykorzystywany przede wszystkim na stronach.
\end_layout

\begin_layout Standard
Język imperatywny z wieloma elementami jeżyka strukturalnego.
\end_layout

\begin_layout Standard
Wykonywany po stronie klienta (przeglądarki).
\end_layout

\begin_layout Standard
Oparty o zdarzenia, tzn.
 funkcjonuje tylko na zdarzeniach.
\end_layout

\begin_layout Standard
W pełni obiektowy - wszystko jest obiektem (nawet prymitywy).
\end_layout

\begin_layout Standard
Można dynamicznie definiować obietky oraz rozszerzać istniejące w oparciu
 o prototypy.
\end_layout

\begin_layout Standard
Nie jest typowany statycznie, ale można sprawdzać typy i rzutować, rzutowanie
 poprzez odpowiednie funkcje.
\end_layout

\begin_layout Standard
Zarządzanie pamięcią jest automatyczne.
\end_layout

\begin_layout Standard
Funkcje mogą przyjmować nieokreśloną ilość parametrów niezależnie od deklaracji
 funkcji.
\end_layout

\begin_layout Section
Omówić kolejne kroki obsługi technologii AJAX z wykorzystaniem PHP
\end_layout

\begin_layout Standard
Obsługa XML w PHP? SimpleXML (parsuje do drzewa obiektowego), XMLReader/Writer.
\end_layout

\begin_layout Standard
X_REQUESTED_WITH => XMLHttpRequest
\end_layout

\begin_layout Standard
"HTTP_ACCEPT"=>"application/json, */*; q=0.01",
\end_layout

\begin_layout Section
Wymienić i opisać funkcje i operatory stosowane w SQL/XML
\end_layout

\begin_layout Subsubsection*
Funkcje
\end_layout

\begin_layout Itemize
XMLElement – tworzy element XML z danych nie-XML
\end_layout

\begin_layout Itemize
XMLForest – tworzy las elementów XML z danych nie-XML
\end_layout

\begin_layout Itemize
XMLGen – tworzy element XML z wykorzystaniem szablonu
\end_layout

\begin_layout Itemize
XMLConcat – tworzy las elementów przez konkatenację elementów XML wywiedzionych
 z jednego wiersza relacji
\end_layout

\begin_layout Itemize
XMLAgg – tworzy las elementów z kolekcji elementów XML wywiedzionych z różnych
 wierszy relacji
\end_layout

\begin_layout Subsubsection*
Operatory
\end_layout

\begin_layout Itemize
existsNode().
 This is used in the WHERE clause of a SQL statement to restrict the set
 of documents returned by a query.
 The existsNode() operator takes an XPath expression and applies it an XML
 document.
 The operator and returns true (1) or false (0) depending on whether or
 not the document contains a node which matches the XPath expression.
\end_layout

\begin_layout Itemize
extract().
 This takes an XPath expression and returns the nodes that match the expression
 as an XML document or fragment.
 If only a single node matches the XPath expression, the result is a well-formed
 XML document.
 If multiple nodes match the XPath expression, the result is a document
 fragment.
\end_layout

\begin_layout Itemize
extractValue().
 This takes an XPath expression and returns the corresponding leaf level
 node.
 The XPath expression passed to extractValue() should identify a single
 attribute, or an element which has precisely one text node child.
 The result is returned in the appropriate SQL data type.
\end_layout

\begin_layout Itemize
updateXML().
 This allows partial updates to be made to an XML document, based on a set
 of XPath expressions.
 Each XPath expression identifies a target node in the document, and a new
 value for that node.
 The updateXML() operator allows multiple updates to be specified for a
 single XML document.
\end_layout

\begin_layout Itemize
XMLSequence().
 This makes it possible to expose the members of a collection as a virtual
 table
\end_layout

\begin_layout Section
Podać i omówić przykład schematu XML w DTD
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!ELEMENT people_list (person)*>
\end_layout

\begin_layout Plain Layout

<!ELEMENT person (name, birthdate?, gender?, socialsecuritynumber?)>
\end_layout

\begin_layout Plain Layout

<!ELEMENT name (#PCDATA)>
\end_layout

\begin_layout Plain Layout

<!ELEMENT birthdate (#PCDATA)>
\end_layout

\begin_layout Plain Layout

<!ELEMENT gender (#PCDATA)>
\end_layout

\begin_layout Plain Layout

<!ELEMENT socialsecuritynumber (#PCDATA)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
\end_layout

\begin_layout Plain Layout

<!DOCTYPE people_list SYSTEM "example.dtd">
\end_layout

\begin_layout Plain Layout

<people_list>
\end_layout

\begin_layout Plain Layout

  <person>
\end_layout

\begin_layout Plain Layout

    <name>Fred Bloggs</name>
\end_layout

\begin_layout Plain Layout

    <birthdate>2008-11-27</birthdate>
\end_layout

\begin_layout Plain Layout

    <gender>Male</gender>
\end_layout

\begin_layout Plain Layout

  </person>
\end_layout

\begin_layout Plain Layout

</people_list> 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Podać i omówić przykład schematu XML w XML Schema
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0"?>
\end_layout

\begin_layout Plain Layout

<note
\end_layout

\begin_layout Plain Layout

xmlns="http://www.w3schools.com"
\end_layout

\begin_layout Plain Layout

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
\end_layout

\begin_layout Plain Layout

xsi:schemaLocation="http://www.w3schools.com note.xsd">
\end_layout

\begin_layout Plain Layout

  <to>Tove</to>
\end_layout

\begin_layout Plain Layout

  <from>Jani</from>
\end_layout

\begin_layout Plain Layout

  <heading>Reminder</heading>
\end_layout

\begin_layout Plain Layout

  <body>Don't forget me this weekend!</body>
\end_layout

\begin_layout Plain Layout

</note>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0"?>
\end_layout

\begin_layout Plain Layout

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
\end_layout

\begin_layout Plain Layout

targetNamespace="http://www.w3schools.com"
\end_layout

\begin_layout Plain Layout

xmlns="http://www.w3schools.com"
\end_layout

\begin_layout Plain Layout

elementFormDefault="qualified">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xs:element name="note">
\end_layout

\begin_layout Plain Layout

  <xs:complexType>
\end_layout

\begin_layout Plain Layout

    <xs:sequence>
\end_layout

\begin_layout Plain Layout

      <xs:element name="to" type="xs:string"/>
\end_layout

\begin_layout Plain Layout

      <xs:element name="from" type="xs:string"/>
\end_layout

\begin_layout Plain Layout

      <xs:element name="heading" type="xs:string"/>
\end_layout

\begin_layout Plain Layout

      <xs:element name="body" type="xs:string"/>
\end_layout

\begin_layout Plain Layout

    </xs:sequence>
\end_layout

\begin_layout Plain Layout

  </xs:complexType>
\end_layout

\begin_layout Plain Layout

</xs:element>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

</xs:schema>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Omówić możliwość przetwarzania dokumentów XML w XQuery
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.w3.org/TR/xquery/#id-path-expressions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To język zapytań (jednakże posiadający pewne cechy języka programowania)
 służący do przeszukiwania dokumentów XML.
\end_layout

\begin_layout Itemize
Zapytania typu FLWOR (FOR, LET, WHERE, ORDER BY, RETURN)
\end_layout

\begin_layout Itemize
Wyrażenia ścieżkowe
\end_layout

\begin_deeper
\begin_layout Itemize
osie
\end_layout

\begin_deeper
\begin_layout Itemize
child
\end_layout

\begin_layout Itemize
descendant
\end_layout

\begin_layout Itemize
parent
\end_layout

\begin_layout Itemize
ancestor
\end_layout

\begin_layout Itemize
following-sibling
\end_layout

\begin_layout Itemize
preceding-sibling
\end_layout

\begin_layout Itemize
following
\end_layout

\begin_layout Itemize
preceding
\end_layout

\begin_layout Itemize
attribute
\end_layout

\begin_layout Itemize
self
\end_layout

\begin_layout Itemize
descendant-or-self
\end_layout

\begin_layout Itemize
ancestor-or-self
\end_layout

\end_deeper
\begin_layout Itemize
testy
\end_layout

\begin_deeper
\begin_layout Itemize
node() - jakikolwiek węzeł
\end_layout

\begin_layout Itemize
text() - tylko węzły tekstowe
\end_layout

\begin_layout Itemize
comment() - tylko węzły komentarza
\end_layout

\begin_layout Itemize
element() - tylko elementy
\end_layout

\begin_layout Itemize
schema-element(person) - elementy których schemat bazuje na schemacie elementu
 person
\end_layout

\begin_layout Itemize
element(person) - elementy o nazwie person
\end_layout

\begin_layout Itemize
attribute() - atrybuty
\end_layout

\begin_layout Itemize
attribute(price) - atrybuty o nazwie price
\end_layout

\begin_layout Itemize
document-node() - węzły dokumentu
\end_layout

\end_deeper
\begin_layout Itemize
predykaty
\end_layout

\begin_deeper
\begin_layout Itemize
np.
 descendant::toy[attribute::color = "red"]
\end_layout

\end_deeper
\begin_layout Itemize
filtry
\end_layout

\begin_deeper
\begin_layout Itemize
np.
 $products[price gt 100]
\end_layout

\end_deeper
\begin_layout Itemize
wyrażenia logiczne
\end_layout

\begin_deeper
\begin_layout Itemize
np.
 1 eq 2 and 3 idiv 0 = 1 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

   for $d in doc("dzialy.xml")//nrdzialu
\end_layout

\begin_layout Plain Layout

   let $p := doc("pracownicy.xml")//pracownik[nrdzialu = $d]
\end_layout

\begin_layout Plain Layout

   where count($p) >= 10
\end_layout

\begin_layout Plain Layout

   order by avg($p/pensja) descending
\end_layout

\begin_layout Plain Layout

   return
\end_layout

\begin_layout Plain Layout

     <ZbiorczoDzial>
\end_layout

\begin_layout Plain Layout

        { $d,
\end_layout

\begin_layout Plain Layout

           <zatrudnionych>{count($p)}</zatrudnionych>,
\end_layout

\begin_layout Plain Layout

           <sredniapensja>{avg($p/salary)}</sredniapensja>
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

     </ZbiorczoDzial>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scharakteryzować obsługę baz danych w PHP
\end_layout

\begin_layout Standard
Istnieją implementacje dla większości popularnych baz danych i są to rozwiązania
 oparte o funkcje.
\end_layout

\begin_layout Standard
Wyjątkiem tutaj jest rozszerzenie MySQLi (imporoved mysql) które może być
 wykorzystywane zarówno obiektowo jak i poprzez funkcje.
 Połączenie jest reprezentowane przez obiekt.
\end_layout

\begin_layout Standard
Do tej całej watachy dochodzi jeszcze PDO - PHP Data Objects - obiektowa
 warstwa abstrakcji na większość popularnych baz danych.
\end_layout

\begin_layout Standard
Wspiera ODBC.
\end_layout

\begin_layout Standard
W PHP nie ma modelu O/R.
\end_layout

\begin_layout Section
Scharakteryzować obsługę baz danych w Javie
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Java_DataBase_Connectivity
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Java DataBase Connectivity (JDBC)
\end_layout

\begin_layout Standard
Interfejs programowania opracowany w 1996 r.
 przez Sun Microsystems, umożliwiający niezależnym od platformy aplikacjom
 napisanym w języku Java porozumiewać się z bazami danych za pomocą języka
 SQL.
 Interfejs ten jest odpowiednikiem standardu ODBC opracowanego przez SQL
 Access Group.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Connection conn = DriverManager.getConnection(
\end_layout

\begin_layout Plain Layout

     "jdbc:somejdbcvendor:other data needed by some jdbc vendor",
\end_layout

\begin_layout Plain Layout

     "myLogin",
\end_layout

\begin_layout Plain Layout

     "myPassword" );
\end_layout

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

     /* you use the connection here */
\end_layout

\begin_layout Plain Layout

} finally {
\end_layout

\begin_layout Plain Layout

    //It's important to close the connection when you are done with it
\end_layout

\begin_layout Plain Layout

    try { conn.close(); } catch (Throwable ignore) { /* Propagate the original
 exception
\end_layout

\begin_layout Plain Layout

instead of this one that you may want just logged */ }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Statement stmt = conn.createStatement();
\end_layout

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

    ResultSet rs = stmt.executeQuery( "SELECT * FROM MyTable" );
\end_layout

\begin_layout Plain Layout

    try {
\end_layout

\begin_layout Plain Layout

        while ( rs.next() ) {
\end_layout

\begin_layout Plain Layout

            int numColumns = rs.getMetaData().getColumnCount();
\end_layout

\begin_layout Plain Layout

            for ( int i = 1 ; i <= numColumns ; i++ ) {
\end_layout

\begin_layout Plain Layout

               // Column numbers start at 1.
\end_layout

\begin_layout Plain Layout

               // Also there are many methods on the result set to return
\end_layout

\begin_layout Plain Layout

               //  the column as a particular type.
 Refer to the Sun documentation
\end_layout

\begin_layout Plain Layout

               //  for the list of valid conversions.
\end_layout

\begin_layout Plain Layout

               System.out.println( "COLUMN " + i + " = " + rs.getObject(i)
 );
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    } finally {
\end_layout

\begin_layout Plain Layout

        try { rs.close(); } catch (Throwable ignore) { /* Propagate the original
 exception
\end_layout

\begin_layout Plain Layout

instead of this one that you may want just logged */ }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} finally {
\end_layout

\begin_layout Plain Layout

    try { stmt.close(); } catch (Throwable ignore) { /* Propagate the original
 exception
\end_layout

\begin_layout Plain Layout

instead of this one that you may want just logged */ }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Hibernate
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Hibernate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Framework do realizacji warstwy dostępu do danych (ang.
 persistance layer).
 Zapewnia on przede wszystkim translację danych pomiędzy relacyjną bazą
 danych, a światem obiektowym (ang.
 O/R mapping).
 Opiera się na wykorzystaniu opisu struktury danych za pomocą języka XML,
 dzięki czemu można "rzutować" obiekty, stosowane w obiektowych językach
 programowania, takich jak Java bezpośrednio na istniejące tabele bazy danych.
 Dodatkowo Hibernate zwiększa wydajność operacji na bazie danych dzięki
 buforowaniu i minimalizacji liczby przesyłanych zapytań.
\end_layout

\begin_layout Section
Omówić metody zabezpieczania internetowych baz danych
\end_layout

\begin_layout Standard
Nie powinno się wystawiać bazy, a jedynie interfejs do niej (aplikacja).
\end_layout

\begin_layout Standard
Firewall
\end_layout

\begin_layout Standard
Niestandardowe nazwy użytkowników administracyjnych.
\end_layout

\begin_layout Standard
Trudne hasła.
\end_layout

\begin_layout Standard
Każda aplikacja powinna posiadać własnego użytkownika.
\end_layout

\begin_layout Standard
Maksymalne ograniczenie uprawnień dla danego użytkownika.
\end_layout

\begin_layout Standard
Używanie połączeń szyfrowanych (SSL).
\end_layout

\begin_layout Standard
Stosuje się różne metody szyfrowania baz danych.
\end_layout

\begin_layout Section
Scharakteryzować modele danych multimedialnych w systemach internetowych
\end_layout

\begin_layout Itemize
Systemy komercyjne (Oracle, IBM DB2):
\end_layout

\begin_deeper
\begin_layout Itemize
wykorzystanie rozszerzeń obiektowo-relacyjnych
\end_layout

\begin_layout Itemize
rozwiązania firmowe dla metadanych sygnałowych
\end_layout

\begin_layout Itemize
prawie brak wsparcia dla metadanych semantycznych
\end_layout

\end_deeper
\begin_layout Itemize
Standardy:
\end_layout

\begin_deeper
\begin_layout Itemize
SQL/MM – model obiektowo-relacyjny; brak wsparcia dla metadanych semantycznych
\end_layout

\begin_layout Itemize
MPEG-7 – reprezentacja wszystkich typów metadanych w postaci XML; na razie
 słabe wsparcie przez systemy zarządzania bazą danych
\end_layout

\end_deeper
\begin_layout Section
Wymienić i omówić kolejne kroki wytwarzania witryn internetowych
\end_layout

\begin_layout Enumerate
Planowanie
\end_layout

\begin_deeper
\begin_layout Enumerate
specyfikacja wymagań, czyli co chce klient
\end_layout

\end_deeper
\begin_layout Enumerate
Analiza
\end_layout

\begin_deeper
\begin_layout Enumerate
analiza wymagań i studium wykonalności, czyli co można faktycznie zrobić
 i jak
\end_layout

\end_deeper
\begin_layout Enumerate
Projekt
\end_layout

\begin_deeper
\begin_layout Enumerate
projekt systemu, poszczególnych struktur, komponentów, modułów
\end_layout

\end_deeper
\begin_layout Enumerate
Implementacja
\end_layout

\begin_deeper
\begin_layout Enumerate
wytwarzanie kodu
\end_layout

\end_deeper
\begin_layout Enumerate
Testowanie
\end_layout

\begin_deeper
\begin_layout Enumerate
testowanie poszczególnych elementów systemu
\end_layout

\begin_layout Enumerate
testowanie systemu w całości
\end_layout

\end_deeper
\begin_layout Enumerate
Wdrożenie i pielęgnacja
\end_layout

\begin_layout Section
Omówić rolę administratora systemu informatycznego
\end_layout

\begin_layout Subsection*
Administrator
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Administrator_(informatyka)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Informatyk zajmujący się zarządzaniem systemem informatycznym i odpowiadający
 za jego sprawne działanie.
 Wyróżnia się administratorów:
\end_layout

\begin_layout Itemize
systemów operacyjnych
\end_layout

\begin_layout Itemize
baz danych
\end_layout

\begin_layout Itemize
serwerów
\end_layout

\begin_layout Itemize
sieci
\end_layout

\begin_layout Itemize
poszczególnych usług typu fora dyskusyjne, czaty itp., gdzie rola administratora
 sprowadza się przede wszystkim do moderowania.
\end_layout

\begin_layout Subsection*
Zadania
\end_layout

\begin_layout Standard
Do zadań administratora należy nadzorowanie pracy serwerów, dodawanie, ewentualn
a edycja danych, i kasowanie kont ich użytkowników, konfiguracja komputerów,
 instalowanie oprogramowania, dbanie o bezpieczeństwo systemu i opcjonalnie
 samych danych, nadzorowanie, wykrywanie i eliminowanie nieprawidłowości,
 asystowanie i współpraca z zewnętrznymi specjalistami przy pracach instalacyjny
ch, konfiguracyjnych i naprawczych, dbanie o porządek (dotyczy w szczególności
 forów internetowych) itp.
\end_layout

\begin_layout Standard
Ze względu na zakres obowiązków, specjalistyczna wiedza typowego administratora
 może wykraczać poza znajomość administracji powierzonego mu oprogramowania
 lub sieci, i dotyczyć pogranicza takich kategorii jak m.in.: elektronika,
 znajomość wielu różnych języków programowania, kryptografia i kryptoanaliza,
 etyka.
\end_layout

\begin_layout Section
Charakterystyka infrastruktur klucza publicznego PKI
\end_layout

\begin_layout Standard
Zarządzanie kluczami (PKI - Public Key Infrastructure) to zestaw sprzętu,
 oprogramowania, ludzi i procedur potrzebnych do tworzenia, zarządzania,
 dystrybucji, wykorzystania, przechowywania i unieważniania cyfrowych certyfikat
ów.
\end_layout

\begin_layout Standard
Obejmuje:
\end_layout

\begin_layout Itemize
wytwarzanie kluczy,
\end_layout

\begin_layout Itemize
poświadczanie (certyfikaty),
\end_layout

\begin_layout Itemize
uzgadnianie (ustanawianie), wymiana,
\end_layout

\begin_layout Itemize
stosowanie (dobór) i użytkowanie,
\end_layout

\begin_layout Itemize
przechowywanie, w tym przekazywanie TTP i organom prawnym (escrow),
\end_layout

\begin_layout Itemize
niszczenie i unieważnianie.
\end_layout

\begin_layout Standard
PKI to infrastruktura pozwalająca na przypisanie klucza publicznego do podmiotu
 za pośrednictwem urzędów poświadczających klucze publiczne (CA).
\end_layout

\begin_layout Itemize
X.509
\end_layout

\begin_deeper
\begin_layout Itemize
hierarchiczny system urzędów certyfikujących (CA)
\end_layout

\begin_layout Itemize
tylko CA mogą podpisywać certyfikaty
\end_layout

\end_deeper
\begin_layout Itemize
PGP
\end_layout

\begin_deeper
\begin_layout Itemize
sieć zaufania (web of trust)
\end_layout

\begin_layout Itemize
wszyscy mogą podpisywać certyfikaty
\end_layout

\end_deeper
\begin_layout Enumerate
Dystrybucja kluczy
\end_layout

\begin_deeper
\begin_layout Enumerate
PGP - Klucze jawne PGP typowo rozprowadza się pocztą elektroniczną, za pomocą
 sieciowych biuletynów informacyjnych lub serwerów kluczy opartych na poczcie
 elektronicznej.
 W celu przeciwdziałania sabotażom klucze są podpisywane przez trzecie strony
 - innych użytkowników.
\end_layout

\begin_layout Enumerate
PEM - CA jest obdarzoną powszech-nym zaufaniem (TTP) bazą kluczy jawnych.
 Klucze jawne PEM mogą być rozprowadzane za pomocą dowolnych środków, zwykle
 pocztą elektroniczną lub za pomocą przeglądania katalogów zbudowanych w
 oparciu o standard X.500.
\end_layout

\end_deeper
\begin_layout Enumerate
Unieważnianie kluczy
\end_layout

\begin_deeper
\begin_layout Enumerate
PGP - Dystrybucja kluczy jest doraźna i w znacznej części na drodze ustnej.
 W tej sytuacji niemożliwe jest zagwarantowanie unieważnienia certyfikatu,
 jeżeli jest on skompromitowany.
\end_layout

\begin_layout Enumerate
PEM - Listy unieważnień certyfikatów (CRL) są zachowane w katalogach typu
 X.500 lub w skrzynkach pocztowych utrzymywanych przez każdy urząd typu PCA
\end_layout

\end_deeper
\begin_layout Section
Protokół SSL/TSL i jego zastosowania
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Transport_Layer_Security
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TLS zapewnia poufność i integralność transmisji danych, a także uwierzytelnienie
 serwera, a niekiedy również klienta.
 Opiera się na szyfrowaniu asymetrycznym oraz certyfikatach X.509.
 
\end_layout

\begin_layout Standard
Według modelu OSI, TLS działa w warstwie prezentacji, dzięki czemu może
 zabezpieczać protokoły warstwy najwyższej – warstwy aplikacji, np.: telnet,
 HTTP, gopher, POP3, IMAP, NNTP, SIP.
 
\end_layout

\begin_layout Section
Aktorzy i przebieg ataków typu DDoS
\end_layout

\begin_layout Subsection
Ataki DoS/DDoS mają dwa typy ofiar
\end_layout

\begin_layout Enumerate
docelowa ofiara i 
\end_layout

\begin_layout Enumerate
pośredniczące systemy, na których działają exploity I demony atakującego.
\end_layout

\begin_layout Enumerate
administrator siecie botnet
\end_layout

\begin_layout Subsection
Fazy ataku DDoS:
\end_layout

\begin_layout Enumerate
Intruz wynajduje jeden lub więcej systemów w Internecie takich, że mogą
 dać się skompromitować i zainstalować exploity intruza.
 Najczęściej wykorzystuje do tego celu wykradzione dane legalnego użytkownika,
 wybierając przy tym systemy z szerokopasmowym dostępem, np.
 węzły akademickie.
 
\end_layout

\begin_layout Enumerate
Na skompromitowany system ładuje dowolną liczbę narzędzi hakerskich (np.
 skanery, wykrywacze typu SO, programy Dos/DDoS).
 Taki system staje się Masterem, który rozpoczyna poszukiwanie innych systemów
 możliwych do skompromitowania.
 Przeszukuje także systemy w sieci lokalnej pod katem uruchomionych usług,
 wynajdując te z podatnościami (masowe wnikanie).
 Automatyczne narzędzie do tej kompromitacji systemów nie są częścią narzędzi
 DDoS, ale pochodzą najczęściej od innych grup hakerów.
 Te skompromitowane systemy stają się początkowymi ofiarami DDoS – zostają
 na nich uruchomione demony DDoS przeprowadzające właściwy atak.
 
\end_layout

\begin_layout Enumerate
Intruz dysponuje listą „posiadanych” systemów z demonami DDoS.
 Właściwa faza DDoS zaczyna się, gdy na systemie Master zostaje uruchomiony
 program, który komunikuje się z demonami, wydając polecenie rozpoczęcia
 ataku.
 Tę komunikację można tak ukryć, że staje się trudna do wykrycia, aczkolwiek
 istnieją pewne dowody na to, występuje.
 W większości przypadków administratorzy zaatakowanych systemów (demonów)
 nawet nie podejrzewają, że demony DDoS w nich działają.
 Nawet zostaną one zlokalizowane i usunięte, to nie można określić, gdzie
 jeszcze znajduje się takie oprogramowanie.
 
\end_layout

\begin_layout Section
Bezpieczeństwo transakcji elektronicznych i protokół SET
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pl.wikipedia.org/wiki/Secure_Electronic_Transaction
\end_layout

\end_inset


\end_layout

\begin_layout Standard
SET (Secure Electronic Transaction) to protokół bezpiecznych transakcji
 elektronicznych.
 Jest standardem umożliwiającym bezpieczne przeprowadzenie transakcji z
 wykluczeniem bezpośredniego kontaktu przez Internet, z użyciem kart kredytowych.
 Projekt ten został ogłoszony 1 lutego 1996 roku.
 Popierany przez dwie największe organizacje związane z kartami płatniczymi
 - Visa i MasterCard oraz wspierany przez firmę IBM.
 Protokół ten posiada cechy następujących technologii: SSL, STT, SEPP, SHTTP.
 
\end_layout

\begin_layout Standard
System SET umożliwia komunikującym się stroną wymianę informacji w bezpieczny
 sposób.
 SET wykorzystuje kryptograficzną metodę umożliwiającą zastąpienie numeru
 karty kredytowej certyfikatem.
 Dzięki temu sprzedawca nie otrzymuje numeru karty kredytowej.
\end_layout

\begin_layout Standard
Do przeprowadzenia transakcji wymagane są:
\end_layout

\begin_layout Itemize
Po stronie klienta - przegladarka internetowa, system operacyjny posiadajacy
 mechanizmy służące do obsługi certyfikatów (np.
 repozytorium)
\end_layout

\begin_layout Itemize
Po stronie sprzedawcy - serwer obsługujący protokół SET
\end_layout

\begin_layout Standard
Protokół SET nie uzyskał jednak adaptacji na szeroką skalę, powodami tego
 są:
\end_layout

\begin_layout Itemize
Wymagana jest instalacja specjalnego oprogramowania (e-portfela)
\end_layout

\begin_layout Itemize
Wysokie koszty i relatywna złożoność procesu wdrożenia przez sprzedawców
 w porównaniu z alternatywnymi metodami opartymi o protokół SSL
\end_layout

\begin_layout Itemize
Problematyczna dystrybucja certyfikatów klienta
\end_layout

\begin_layout Section
Na czym polega bezpieczeństwo usługi znakowania czasem?
\end_layout

\begin_layout Standard
Bezpieczeństwo notariatu opiera się na podpisie złożonym przez zaufaną instytucj
ę, stwierdzającym, że dany dokument rzeczywiście istniał o danym czasie
 i na braku możliwości zafałszowania informacji o dacie, zmiany treści,
 czy przeniesienia podpisu na inny dokument.
 
\end_layout

\begin_layout Itemize
Użytkownik wysyła skrót wiadomości do notariatu cyfrowego.
 
\end_layout

\begin_layout Itemize
Na serwerze notariatu gromadzone są skróty dokumentów przesłane w tej samej
 sekundzie od różnych klientów.
 
\end_layout

\begin_layout Itemize
Na ich podstawie budowany jest łączny skrót wielu dokumentów z tej samej
 sekundy, ten dodawany jest do sumy skrótów bazowych w tzw Super skrót bazowy
 (SHV super hash value) z poprzedniej sekundy dając nowy skrót dla danej
 sekundy.
 
\end_layout

\begin_layout Itemize
Takie rozwiązanie daje powiązanie skrótu danego dokumentu z wszystkimi innymi
 dokumentami z danej chwili i z poprzednimi poświadczeniami dokumentów.
 
\end_layout

\begin_layout Itemize
W każdej następnej chwili dołączane są kolejne skróty, dając w ten sposób
 umiejscowienie skrótu wśród innych tego rodzaju „odcisków palca”.
 
\end_layout

\begin_layout Itemize
Zwrotnie użytkownik otrzymuje poświadczenie zarejestrowania skrótu i certyfikat
 dokumentu (Serwer nie może ich zmieniać) skróty są gromadzone w centralnym
 rejestrze i publikowane za pomocą różnych środków.
 
\end_layout

\begin_layout Subsection
Elementy
\end_layout

\begin_layout Enumerate
dokument i jego skrót
\end_layout

\begin_layout Enumerate
serwer obliczający root hash (hash hashy dokumentów z danej sekundy) i SHV
 (Super Hash Value - root hash i SHV z poprzedniej sekundy)
\end_layout

\begin_layout Enumerate
certyfikat dokumentu - potwierdza zarejestrowanie skrótu dokumentu w systemie
\end_layout

\begin_layout Enumerate
publikacja SHV za pomocą różnych środków
\end_layout

\begin_layout Subsection
Elementy
\end_layout

\begin_layout Enumerate
Powiązanie z innymi dokumentami
\end_layout

\begin_layout Enumerate
Umiejscowienie w czasie
\end_layout

\begin_layout Enumerate
Powiązany z całą historią skrótów
\end_layout

\begin_layout Enumerate
Masowa publikacja
\end_layout

\begin_layout Subsection
Uzasadnienie
\end_layout

\begin_layout Standard
Zmiana dokumentu wymagała by przeliczenia wszystkich skrótów wystawionych
 do chwili obecnej oraz zmiany wszystkich opublikowanych wartości SHV po
 zgłoszeniu oryginalnego dokumentu.
\end_layout

\end_body
\end_document
